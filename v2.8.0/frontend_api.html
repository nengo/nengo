

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Nengo frontend API &#8212; Nengo core 2.8.0 docs</title>
    <link rel="stylesheet" href="_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Setting parameters with Configs" href="config.html" />
    <link rel="prev" title="User guide" href="user_guide.html" />
<link rel="stylesheet" type="text/css" href="_static/custom.css">


  
   

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="config.html" title="Setting parameters with Configs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="user_guide.html" title="User guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Nengo core 2.8.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user_guide.html" accesskey="U">User guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
        <a href="
    index.html" class="text-logo">Nengo core 2.8</a>
        <div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="user_guide.html">User guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Nengo frontend API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nengo-objects">Nengo Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributions">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#neuron-types">Neuron types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#learning-rule-types">Learning rule types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processes">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synapse-models">Synapse models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decoder-and-connection-weight-solvers">Decoder and connection weight solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Setting parameters with Configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Reusable networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="spa.html">Semantic Pointer Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html">Advanced topics</a></li>
<li class="toctree-l2"><a class="reference internal" href="backend_api.html">Nengo backend API</a></li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html">Release History</a></li>
<li class="toctree-l2"><a class="reference internal" href="history.html">Nengo history</a></li>
<li class="toctree-l2"><a class="reference internal" href="converting.html">Converting from Nengo 1.4 to Nengo 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to Nengo</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.nengo.ai/projects.html">Nengo ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Nengo license</a></li>
</ul>

    
  </div>
</div>
        
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
    </div>
  </div>
        <div id="right-column">
          
  <div class="header">
    
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="index.html">Docs</a></li>
              
                <li><a href="user_guide.html">User guide</a></li>
              
              <li>Nengo frontend API</li>
            </ol>
          </div>
          
    
  </div>

          <div class="document clearer body">
            
  <div class="section" id="nengo-frontend-api">
<h1>Nengo frontend API<a class="headerlink" href="#nengo-frontend-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="nengo-objects">
<h2>Nengo Objects<a class="headerlink" href="#nengo-objects" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Network</span></code></a></td>
<td>A network contains ensembles, nodes, connections, and other networks.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Ensemble</span></code></a></td>
<td>A group of neurons that collectively represent a vector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal"><span class="pre">nengo.ensemble.Neurons</span></code></a></td>
<td>An interface for making connections directly to an ensemble’s neurons.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Node</span></code></a></td>
<td>Provide non-neural inputs to Nengo objects and process outputs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Connection</span></code></a></td>
<td>Connects two objects together.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.connection.LearningRule" title="nengo.connection.LearningRule"><code class="xref py py-obj docutils literal"><span class="pre">nengo.connection.LearningRule</span></code></a></td>
<td>An interface for making connections to a learning rule.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Probe</span></code></a></td>
<td>A probe is an object that collects data from the simulation.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.Network">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Network</code><span class="sig-paren">(</span><em>label=None</em>, <em>seed=None</em>, <em>add_to_container=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>A network contains ensembles, nodes, connections, and other networks.</p>
<p>A network is primarily used for grouping together related
objects and connections for visualization purposes.
However, you can also use networks as a nice way to reuse
network creation code.</p>
<p>To group together related objects that you do not need to reuse,
you can create a new <code class="docutils literal"><span class="pre">Network</span></code> and add objects in a <code class="docutils literal"><span class="pre">with</span></code> block.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Vision&quot;</span><span class="p">):</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Motor&quot;</span><span class="p">):</span>
        <span class="n">sma</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">sma</span><span class="p">)</span>
</pre></div>
</div>
<p>To reuse a group of related objects, you can create a new subclass
of <code class="docutils literal"><span class="pre">Network</span></code>, and add objects in the <code class="docutils literal"><span class="pre">__init__</span></code> method.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OcularDominance</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">LIF</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="n">left_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">right_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">left_eye</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="n">right_eye</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: None)</span></dt>
<dd><p class="first last">Name of the network.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed that will be fed to the random number generator.
Setting the seed makes the network’s build process deterministic.</p>
</dd>
<dt><strong>add_to_container</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: None)</span></dt>
<dd><p class="first last">Determines if this network will be added to the current container.
If None, this network will be added to the network at the top of the
<code class="docutils literal"><span class="pre">Network.context</span></code> stack unless the stack is empty.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>connections</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> instances in this network.</p>
</dd>
<dt><strong>ensembles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal"><span class="pre">Ensemble</span></code></a> instances in this network.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of this network.</p>
</dd>
<dt><strong>networks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal"><span class="pre">Network</span></code></a> instances in this network.</p>
</dd>
<dt><strong>nodes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal"><span class="pre">Node</span></code></a> instances in this network.</p>
</dd>
<dt><strong>probes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal"><span class="pre">Probe</span></code></a> instances in this network.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Random seed used by this network.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="staticmethod">
<dt id="nengo.Network.add">
<em class="property">static </em><code class="descname">add</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the passed object to <code class="docutils literal"><span class="pre">Network.context</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="nengo.Network.default_config">
<em class="property">static </em><code class="descname">default_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/network.html#Network.default_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.default_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a <a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal"><span class="pre">Config</span></code></a> object for setting defaults.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_objects">
<code class="descname">all_objects</code><a class="headerlink" href="#nengo.Network.all_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All objects in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_ensembles">
<code class="descname">all_ensembles</code><a class="headerlink" href="#nengo.Network.all_ensembles" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All ensembles in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_nodes">
<code class="descname">all_nodes</code><a class="headerlink" href="#nengo.Network.all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All nodes in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_networks">
<code class="descname">all_networks</code><a class="headerlink" href="#nengo.Network.all_networks" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All networks in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_connections">
<code class="descname">all_connections</code><a class="headerlink" href="#nengo.Network.all_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All connections in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.all_probes">
<code class="descname">all_probes</code><a class="headerlink" href="#nengo.Network.all_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All probes in this network and its subnetworks.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.config">
<code class="descname">config</code><a class="headerlink" href="#nengo.Network.config" title="Permalink to this definition">¶</a></dt>
<dd><p>(<a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal"><span class="pre">Config</span></code></a>) Configuration for this network.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Network.n_neurons">
<code class="descname">n_neurons</code><a class="headerlink" href="#nengo.Network.n_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Number of neurons in this network, including subnetworks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Ensemble">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Ensemble</code><span class="sig-paren">(</span><em>n_neurons</em>, <em>dimensions</em>, <em>radius=Default</em>, <em>encoders=Default</em>, <em>intercepts=Default</em>, <em>max_rates=Default</em>, <em>eval_points=Default</em>, <em>n_eval_points=Default</em>, <em>neuron_type=Default</em>, <em>gain=Default</em>, <em>bias=Default</em>, <em>noise=Default</em>, <em>normalize_encoders=Default</em>, <em>label=Default</em>, <em>seed=Default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/ensemble.html#Ensemble"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>A group of neurons that collectively represent a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n_neurons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of neurons.</p>
</dd>
<dt><strong>dimensions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of representational dimensions.</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: 1.0)</span></dt>
<dd><p class="first last">The representational radius of the ensemble.</p>
</dd>
<dt><strong>encoders</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons, dimensions) array_like, optional                (Default: UniformHypersphere(surface=True))</span></dt>
<dd><p class="first last">The encoders used to transform from representational space
to neuron space. Each row is a neuron’s encoder; each column is a
representational dimension.</p>
</dd>
<dt><strong>intercepts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like, optional                  (Default: <code class="docutils literal"><span class="pre">nengo.dists.Uniform(-1.0,</span> <span class="pre">1.0)</span></code>)</span></dt>
<dd><p class="first last">The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal"><span class="pre">c</span></code> is the given intercept.</p>
</dd>
<dt><strong>max_rates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like, optional                 (Default: <code class="docutils literal"><span class="pre">nengo.dists.Uniform(200,</span> <span class="pre">400)</span></code>)</span></dt>
<dd><p class="first last">The activity of each neuron when the input signal <code class="docutils literal"><span class="pre">x</span></code> is magnitude 1
and aligned with that neuron’s encoder <code class="docutils literal"><span class="pre">e</span></code>;
i.e., when <code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>eval_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_eval_points, dims) array_like, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.dists.UniformHypersphere()</span></code>)</span></dt>
<dd><p class="first last">The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</dd>
<dt><strong>n_eval_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">The number of evaluation points to be drawn from the <code class="xref py py-obj docutils literal"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</dd>
<dt><strong>neuron_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal"><span class="pre">NeuronType</span></code></a>, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.LIF()</span></code>)</span></dt>
<dd><p class="first last">The model that simulates all neurons in the ensemble
(see <a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal"><span class="pre">NeuronType</span></code></a>).</p>
</dd>
<dt><strong>gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like (Default: None)</span></dt>
<dd><p class="first last">The gains associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal"><span class="pre">max_rates</span></code> and <code class="docutils literal"><span class="pre">intercepts</span></code>.</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like (Default: None)</span></dt>
<dd><p class="first last">The biases associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal"><span class="pre">max_rates</span></code> and <code class="docutils literal"><span class="pre">intercepts</span></code>.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Process, optional (Default: None)</span></dt>
<dd><p class="first last">Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</dd>
<dt><strong>normalize_encoders</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: True)</span></dt>
<dd><p class="first last">Indicates whether the encoders should be normalized.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: None)</span></dt>
<dd><p class="first last">A name for the ensemble. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">The seed used for random number generation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt>
<dd><p class="first last">The biases associated with each neuron in the ensemble.</p>
</dd>
<dt><strong>dimensions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of representational dimensions.</p>
</dd>
<dt><strong>encoders</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons, dimensions) array_like</span></dt>
<dd><p class="first last">The encoders, used to transform from representational space
to neuron space. Each row is a neuron’s encoder, each column is a
representational dimension.</p>
</dd>
<dt><strong>eval_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_eval_points, dims) array_like</span></dt>
<dd><p class="first last">The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</dd>
<dt><strong>gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt>
<dd><p class="first last">The gains associated with each neuron in the ensemble.</p>
</dd>
<dt><strong>intercepts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons) array_like or None</span></dt>
<dd><p class="first last">The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal"><span class="pre">c</span></code> is the given intercept.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">A name for the ensemble. Used for debugging and visualization.</p>
</dd>
<dt><strong>max_rates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt>
<dd><p class="first last">The activity of each neuron when <code class="docutils literal"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>,
where <code class="docutils literal"><span class="pre">e</span></code> is the neuron’s encoder.</p>
</dd>
<dt><strong>n_eval_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">The number of evaluation points to be drawn from the <code class="xref py py-obj docutils literal"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</dd>
<dt><strong>n_neurons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">The number of neurons.</p>
</dd>
<dt><strong>neuron_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">NeuronType</span></dt>
<dd><p class="first last">The model that simulates all neurons in the ensemble
(see <code class="docutils literal"><span class="pre">nengo.neurons</span></code>).</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Process or None</span></dt>
<dd><p class="first last">Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The representational radius of the ensemble.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">The seed used for random number generation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nengo.Ensemble.neurons">
<code class="descname">neurons</code><a class="headerlink" href="#nengo.Ensemble.neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>A direct interface to the neurons in the ensemble.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Ensemble.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.Ensemble.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Ensemble.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.Ensemble.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.ensemble.Neurons">
<em class="property">class </em><code class="descclassname">nengo.ensemble.</code><code class="descname">Neurons</code><span class="sig-paren">(</span><em>ensemble</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/ensemble.html#Neurons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.ensemble.Neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections directly to an ensemble’s neurons.</p>
<p>This should only ever be accessed through the <code class="docutils literal"><span class="pre">neurons</span></code> attribute of an
ensemble, as a way to signal to <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> that the connection
should be made directly to the neurons rather than to the ensemble’s
decoded value, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="nengo.ensemble.Neurons.ensemble">
<code class="descname">ensemble</code><a class="headerlink" href="#nengo.ensemble.Neurons.ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>(Ensemble) The ensemble these neurons are part of.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.ensemble.Neurons.probeable">
<code class="descname">probeable</code><a class="headerlink" href="#nengo.ensemble.Neurons.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the neuron population.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.ensemble.Neurons.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.ensemble.Neurons.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Node">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>output=Default</em>, <em>size_in=Default</em>, <em>size_out=Default</em>, <em>label=Default</em>, <em>seed=Default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/node.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide non-neural inputs to Nengo objects and process outputs.</p>
<p>Nodes can accept input, and perform arbitrary computations
for the purpose of controlling a Nengo simulation.
Nodes are typically not part of a brain model per se,
but serve to summarize the assumptions being made
about sensory data or other environment variables
that cannot be generated by a brain model alone.</p>
<p>Nodes can also be used to test models by providing specific input signals
to parts of the model, and can simplify the input/output interface of a
<a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal"><span class="pre">Network</span></code></a> when used as a relay to/from its internal
ensembles (see <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal"><span class="pre">EnsembleArray</span></code></a> for an example).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, array_like, or None</span></dt>
<dd><p class="first last">Function that transforms the Node inputs into outputs,
a constant output value, or None to transmit signals unchanged.</p>
</dd>
<dt><strong>size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: 0)</span></dt>
<dd><p class="first last">The number of dimensions of the input data parameter.</p>
</dd>
<dt><strong>size_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">The size of the output signal. If None, it will be determined
based on the values of <code class="docutils literal"><span class="pre">output</span></code> and <code class="docutils literal"><span class="pre">size_in</span></code>.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: None)</span></dt>
<dd><p class="first last">A name for the node. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">The seed used for random number generation.
Note: no aspects of the node are random, so currently setting
this seed has no effect.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the node.</p>
</dd>
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, array_like, or None</span></dt>
<dd><p class="first last">The given output.</p>
</dd>
<dt><strong>size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of dimensions for incoming connection.</p>
</dd>
<dt><strong>size_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of output dimensions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.Connection">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Connection</code><span class="sig-paren">(</span><em>pre</em>, <em>post</em>, <em>synapse=Default</em>, <em>function=Default</em>, <em>transform=Default</em>, <em>solver=Default</em>, <em>learning_rule_type=Default</em>, <em>eval_points=Default</em>, <em>scale_eval_points=Default</em>, <em>label=Default</em>, <em>seed=Default</em>, <em>modulatory=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/connection.html#Connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects two objects together.</p>
<p>The connection between the two object is unidirectional,
transmitting information from the first argument, <code class="docutils literal"><span class="pre">pre</span></code>,
to the second argument, <code class="docutils literal"><span class="pre">post</span></code>.</p>
<p>Almost any Nengo object can act as the pre or post side of a connection.
Additionally, you can use Python slice syntax to access only some of the
dimensions of the pre or post object.</p>
<p>For example, if <code class="docutils literal"><span class="pre">node</span></code> has <code class="docutils literal"><span class="pre">size_out=2</span></code> and <code class="docutils literal"><span class="pre">ensemble</span></code> has
<code class="docutils literal"><span class="pre">size_in=1</span></code>, we could not create the following connection:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<p>But, we could create either of these two connections:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
<span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pre</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble or Neurons or Node</span></dt>
<dd><p class="first last">The source Nengo object for the connection.</p>
</dd>
<dt><strong>post</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble or Neurons or Node or Probe</span></dt>
<dd><p class="first last">The destination object for the connection.</p>
</dd>
<dt><strong>synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Synapse or None, optional               (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=0.005)</span></code>)</span></dt>
<dd><p class="first">Synapse model to use for filtering (see <a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>).
If <em>None</em>, no synapse will be used and information will be transmitted
without any delay (if supported by the backend—some backends may
introduce a single time step delay).</p>
<p class="last">Note that at least one connection must have a synapse that is not
<em>None</em> if components are connected in a cycle. Furthermore, a synaptic
filter with a zero time constant is different from a <em>None</em> synapse
as a synaptic filter will always add a delay of at least one time step.</p>
</dd>
<dt><strong>function</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or (n_eval_points, size_mid) array_like,                optional (Default: None)</span></dt>
<dd><p class="first last">Function to compute across the connection. Note that <code class="docutils literal"><span class="pre">pre</span></code> must be
an ensemble to apply a function across the connection.
If an array is passed, the function is implicitly defined by the
points in the array and the provided <code class="docutils literal"><span class="pre">eval_points</span></code>, which have a
one-to-one correspondence.</p>
</dd>
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(size_out, size_mid) array_like, optional                 (Default: <code class="docutils literal"><span class="pre">np.array(1.0)</span></code>)</span></dt>
<dd><p class="first last">Linear transform mapping the pre output to the post input.
This transform is in terms of the sliced size; if either pre
or post is a slice, the transform must be shaped according to
the sliced dimensionality. Additionally, the function is applied
before the transform, so if a function is computed across the
connection, the transform must be of shape <code class="docutils literal"><span class="pre">(size_out,</span> <span class="pre">size_mid)</span></code>.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver, optional (Default: <code class="docutils literal"><span class="pre">nengo.solvers.LstsqL2()</span></code>)</span></dt>
<dd><p class="first last">Solver instance to compute decoders or weights
(see <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a>). If <code class="docutils literal"><span class="pre">solver.weights</span></code> is True, a full
connection weight matrix is computed instead of decoders.</p>
</dd>
<dt><strong>learning_rule_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">LearningRuleType or iterable of LearningRuleType,                          optional (Default: None)</span></dt>
<dd><p class="first last">Modifies the decoders or connection weights during simulation.</p>
</dd>
<dt><strong>eval_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_eval_points, size_in) array_like or int, optional                   (Default: None)</span></dt>
<dd><p class="first last">Points at which to evaluate <code class="docutils literal"><span class="pre">function</span></code> when computing decoders,
spanning the interval (-pre.radius, pre.radius) in each dimension.
If None, will use the eval_points associated with <code class="docutils literal"><span class="pre">pre</span></code>.</p>
</dd>
<dt><strong>scale_eval_points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: True)</span></dt>
<dd><p class="first last">Indicates whether the evaluation points should be scaled
by the radius of the pre Ensemble.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: None)</span></dt>
<dd><p class="first last">A descriptive label for the connection.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">The seed used for random number generation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>is_decoded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if and only if the connection is decoded. This will not occur
when <code class="docutils literal"><span class="pre">solver.weights</span></code> is True or both pre and post are
<a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal"><span class="pre">Neurons</span></code></a>.</p>
</dd>
<dt><strong>function</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">The given function.</p>
</dd>
<dt><strong>function_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The output dimensionality of the given function. If no function is
specified, function_size will be 0.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A human-readable connection label for debugging and visualization.
If not overridden, incorporates the labels of the pre and post objects.</p>
</dd>
<dt><strong>learning_rule_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance or list or dict of LearningRuleType, optional</span></dt>
<dd><p class="first last">The learning rule types.</p>
</dd>
<dt><strong>post</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble or Neurons or Node or Probe or ObjView</span></dt>
<dd><p class="first last">The given post object.</p>
</dd>
<dt><strong>post_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble or Neurons or Node or Probe</span></dt>
<dd><p class="first last">The underlying post object, even if <code class="docutils literal"><span class="pre">post</span></code> is an <code class="docutils literal"><span class="pre">ObjView</span></code>.</p>
</dd>
<dt><strong>post_slice</strong> <span class="classifier-delimiter">:</span> <span class="classifier">slice or list or None</span></dt>
<dd><p class="first last">The slice associated with <code class="docutils literal"><span class="pre">post</span></code> if it is an ObjView, or None.</p>
</dd>
<dt><strong>pre</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble or Neurons or Node or ObjView</span></dt>
<dd><p class="first last">The given pre object.</p>
</dd>
<dt><strong>pre_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble or Neurons or Node</span></dt>
<dd><p class="first last">The underlying pre object, even if <code class="docutils literal"><span class="pre">post</span></code> is an <code class="docutils literal"><span class="pre">ObjView</span></code>.</p>
</dd>
<dt><strong>pre_slice</strong> <span class="classifier-delimiter">:</span> <span class="classifier">slice or list or None</span></dt>
<dd><p class="first last">The slice associated with <code class="docutils literal"><span class="pre">pre</span></code> if it is an ObjView, or None.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The seed used for random number generation.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver</span></dt>
<dd><p class="first last">The Solver instance that will be used to compute decoders or weights
(see <code class="docutils literal"><span class="pre">nengo.solvers</span></code>).</p>
</dd>
<dt><strong>synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Synapse</span></dt>
<dd><p class="first last">The Synapse model used for filtering across the connection
(see <code class="docutils literal"><span class="pre">nengo.synapses</span></code>).</p>
</dd>
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(size_out, size_mid) array_like</span></dt>
<dd><p class="first last">Linear transform mapping the pre function output to the post input.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nengo.Connection.learning_rule">
<code class="descname">learning_rule</code><a class="headerlink" href="#nengo.Connection.learning_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>(LearningRule or iterable) Connectable learning rule object(s).</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Connection.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.Connection.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the pre object.</p>
<p>Also the input size of the function, if one is specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Connection.size_mid">
<code class="descname">size_mid</code><a class="headerlink" href="#nengo.Connection.size_mid" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the function, if specified.</p>
<p>If the function is not specified, then <code class="docutils literal"><span class="pre">size_in</span> <span class="pre">==</span> <span class="pre">size_mid</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Connection.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.Connection.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of input dimensions of the post object.</p>
<p>Also the number of output dimensions of the transform.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.connection.LearningRule">
<em class="property">class </em><code class="descclassname">nengo.connection.</code><code class="descname">LearningRule</code><span class="sig-paren">(</span><em>connection</em>, <em>learning_rule_type</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/connection.html#LearningRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.connection.LearningRule" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections to a learning rule.</p>
<p>Connections to a learning rule are to allow elements of the network to
affect the learning rule. For example, learning rules that use error
information can obtain that information through a connection.</p>
<p>Learning rule objects should only ever be accessed through the
<code class="docutils literal"><span class="pre">learning_rule</span></code> attribute of a connection.</p>
<dl class="attribute">
<dt id="nengo.connection.LearningRule.connection">
<code class="descname">connection</code><a class="headerlink" href="#nengo.connection.LearningRule.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>(Connection) The connection modified by the learning rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.connection.LearningRule.modifies">
<code class="descname">modifies</code><a class="headerlink" href="#nengo.connection.LearningRule.modifies" title="Permalink to this definition">¶</a></dt>
<dd><p>(str) The variable modified by the learning rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.connection.LearningRule.probeable">
<code class="descname">probeable</code><a class="headerlink" href="#nengo.connection.LearningRule.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the learning rule.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.connection.LearningRule.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.connection.LearningRule.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from learning rules, so always 0.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Probe">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Probe</code><span class="sig-paren">(</span><em>target</em>, <em>attr=None</em>, <em>sample_every=Default</em>, <em>synapse=Default</em>, <em>solver=Default</em>, <em>label=Default</em>, <em>seed=Default</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/probe.html#Probe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Probe" title="Permalink to this definition">¶</a></dt>
<dd><p>A probe is an object that collects data from the simulation.</p>
<p>This is to be used in any situation where you wish to gather simulation
data (spike data, represented values, neuron voltages, etc.) for analysis.</p>
<p>Probes do not directly affect the simulation.</p>
<p>All Nengo objects can be probed (except Probes themselves).
Each object has different attributes that can be probed.
To see what is probeable for each object, print its
<code class="docutils literal"><span class="pre">probeable</span></code> attribute.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">ens</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ens</span><span class="o">.</span><span class="n">probeable</span><span class="p">)</span>
<span class="go">[&#39;decoded_output&#39;, &#39;input&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble, Neurons, Node, or Connection</span></dt>
<dd><p class="first last">The object to probe.</p>
</dd>
<dt><strong>attr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: None)</span></dt>
<dd><p class="first last">The signal to probe. Refer to the target’s <code class="docutils literal"><span class="pre">probeable</span></code> list for
details. If None, the first element in the <code class="docutils literal"><span class="pre">probeable</span></code> list
will be used.</p>
</dd>
<dt><strong>sample_every</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Sampling period in seconds. If None, the <code class="docutils literal"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</dd>
<dt><strong>synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Synapse, optional (Default: None)</span></dt>
<dd><p class="first last">A synaptic model to filter the probed signal.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver, optional (Default: <code class="docutils literal"><span class="pre">ConnectionDefault</span></code>)</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a> to compute decoders
for probes that require them.</p>
</dd>
<dt><strong>label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: None)</span></dt>
<dd><p class="first last">A name for the probe. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">The seed used for random number generation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>attr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">The signal that will be probed. If None, the first element of the
target’s <code class="docutils literal"><span class="pre">probeable</span></code> list will be used.</p>
</dd>
<dt><strong>sample_every</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">Sampling period in seconds. If None, the <code class="docutils literal"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver or None</span></dt>
<dd><p class="first last"><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">Solver</span></code></a> to compute decoders. Only used for probes
of an ensemble’s decoded output.</p>
</dd>
<dt><strong>synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Synapse or None</span></dt>
<dd><p class="first last">A synaptic model to filter the probed signal.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Ensemble, Neurons, Node, or Connection</span></dt>
<dd><p class="first last">The object to probe.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="nengo.Probe.obj">
<code class="descname">obj</code><a class="headerlink" href="#nengo.Probe.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>(Nengo object) The underlying Nengo object target.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Probe.size_in">
<code class="descname">size_in</code><a class="headerlink" href="#nengo.Probe.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Dimensionality of the probed signal.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Probe.size_out">
<code class="descname">size_out</code><a class="headerlink" href="#nengo.Probe.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from probes, so always 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="nengo.Probe.slice">
<code class="descname">slice</code><a class="headerlink" href="#nengo.Probe.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>(slice) The slice associated with the Nengo object target.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="distributions">
<h2>Distributions<a class="headerlink" href="#distributions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Distribution</span></code></a></td>
<td>A base class for probability distributions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.get_samples" title="nengo.dists.get_samples"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.get_samples</span></code></a></td>
<td>Convenience function to sample a distribution or return samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Uniform" title="nengo.dists.Uniform"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Uniform</span></code></a></td>
<td>A uniform distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.Gaussian" title="nengo.dists.Gaussian"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Gaussian</span></code></a></td>
<td>A Gaussian distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Exponential" title="nengo.dists.Exponential"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Exponential</span></code></a></td>
<td>An exponential distribution (optionally with high values clipped).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.UniformHypersphere" title="nengo.dists.UniformHypersphere"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.UniformHypersphere</span></code></a></td>
<td>Uniform distribution on or in an n-dimensional unit hypersphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.Choice" title="nengo.dists.Choice"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Choice</span></code></a></td>
<td>Discrete distribution across a set of possible values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.Samples" title="nengo.dists.Samples"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.Samples</span></code></a></td>
<td>A set of samples.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.PDF" title="nengo.dists.PDF"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.PDF</span></code></a></td>
<td>An arbitrary distribution from a PDF.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SqrtBeta</span></code></a></td>
<td>Distribution of the square root of a Beta distributed random variable.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SubvectorLength</span></code></a></td>
<td>Distribution of the length of a subvectors of a unit vector.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.dists.CosineSimilarity" title="nengo.dists.CosineSimilarity"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.CosineSimilarity</span></code></a></td>
<td>Distribution of the cosine of the angle between two random vectors.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.dists.Distribution">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Distribution</code><a class="reference internal" href="_modules/nengo/dists.html#Distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for probability distributions.</p>
<p>The only thing that a probabilities distribution need to define is a
<a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal"><span class="pre">sample</span></code></a> method. This base class ensures that all distributions
accept the same arguments for the sample function.</p>
<dl class="method">
<dt id="nengo.dists.Distribution.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>n</em>, <em>d=None</em>, <em>rng=np.random</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Distribution.sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number samples to take.</p>
</dd>
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional (Default: None)</span></dt>
<dd><p class="first last">The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt>
<dd><p class="first last">Random number generator state.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n,) or (n, d) array_like</span></dt>
<dd><p class="first last">Samples as a 1d or 2d array depending on <code class="docutils literal"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nengo.dists.get_samples">
<code class="descclassname">nengo.dists.</code><code class="descname">get_samples</code><span class="sig-paren">(</span><em>dist_or_samples</em>, <em>n</em>, <em>d=None</em>, <em>rng=np.random</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#get_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.get_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to sample a distribution or return samples.</p>
<p>Use this function in situations where you accept an argument that could
be a distribution, or could be an <code class="docutils literal"><span class="pre">array_like</span></code> of samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dist_or_samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">Distribution</span></code></a> or (n, d) array_like</span></dt>
<dd><p class="first last">Source of the samples to be returned.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number samples to take.</p>
</dd>
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional (Default: None)</span></dt>
<dd><p class="first last">The number of dimensions to return.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier">RandomState, optional (Default: np.random)</span></dt>
<dd><p class="first last">Random number generator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, d) array_like</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">samples</span> <span class="o">=</span> <span class="n">get_samples</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">0.057277898442269548</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Uniform">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Uniform</code><span class="sig-paren">(</span><em>low</em>, <em>high</em>, <em>integer=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>A uniform distribution.</p>
<p>It’s equally likely to get any scalar between <code class="docutils literal"><span class="pre">low</span></code> and <code class="docutils literal"><span class="pre">high</span></code>.</p>
<p>Note that the order of <code class="docutils literal"><span class="pre">low</span></code> and <code class="docutils literal"><span class="pre">high</span></code> doesn’t matter;
if <code class="docutils literal"><span class="pre">low</span> <span class="pre">&lt;</span> <span class="pre">high</span></code> this will still work, and <code class="docutils literal"><span class="pre">low</span></code> will still
be a closed interval while <code class="docutils literal"><span class="pre">high</span></code> is open.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>low</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Number</span></dt>
<dd><p class="first last">The closed lower bound of the uniform distribution; samples &gt;= low</p>
</dd>
<dt><strong>high</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Number</span></dt>
<dd><p class="first last">The open upper bound of the uniform distribution; samples &lt; high</p>
</dd>
<dt><strong>integer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (Default: False)</span></dt>
<dd><p class="first last">If true, sample from a uniform distribution of integers. In this case,
low and high should be integers.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Gaussian">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Gaussian</code><span class="sig-paren">(</span><em>mean</em>, <em>std</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Gaussian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>A Gaussian distribution.</p>
<p>This represents a bell-curve centred at <code class="docutils literal"><span class="pre">mean</span></code> and with
spread represented by the standard deviation, <code class="docutils literal"><span class="pre">std</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mean</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Number</span></dt>
<dd><p class="first last">The mean of the Gaussian.</p>
</dd>
<dt><strong>std</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Number</span></dt>
<dd><p class="first last">The standard deviation of the Gaussian.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValidationError if std is &lt;= 0</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Exponential">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Exponential</code><span class="sig-paren">(</span><em>scale</em>, <em>shift=0.0</em>, <em>high=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Exponential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>An exponential distribution (optionally with high values clipped).</p>
<p>If <code class="docutils literal"><span class="pre">high</span></code> is left to its default value of infinity, this is a standard
exponential distribution. If <code class="docutils literal"><span class="pre">high</span></code> is set, then any sampled values at
or above <code class="docutils literal"><span class="pre">high</span></code> will be clipped so they are slightly below <code class="docutils literal"><span class="pre">high</span></code>.
This is useful for thresholding and, by extension,
<a class="reference internal" href="networks.html#nengo.networks.AssociativeMemory" title="nengo.networks.AssociativeMemory"><code class="xref py py-obj docutils literal"><span class="pre">networks.AssociativeMemory</span></code></a>.</p>
<p>The probability distribution function (PDF) is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">shift</span>
<span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="n">scale</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">shift</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">high</span>
       <span class="o">|</span>  <span class="n">n</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">high</span> <span class="o">-</span> <span class="n">eps</span>
       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">high</span>
</pre></div>
</div>
<p>where <code class="xref py py-obj docutils literal"><span class="pre">n</span></code> is such that the PDF integrates to one, and <code class="xref py py-obj docutils literal"><span class="pre">eps</span></code> is an
infintesimally small number such that samples of <code class="xref py py-obj docutils literal"><span class="pre">x</span></code> are strictly less than
<code class="xref py py-obj docutils literal"><span class="pre">high</span></code> (in practice, <code class="xref py py-obj docutils literal"><span class="pre">eps</span></code> depends on the floating point precision).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The scale parameter (inverse of the rate parameter lambda). Larger
values make the distribution narrower (sharper peak).</p>
</dd>
<dt><strong>shift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0)</span></dt>
<dd><p class="first last">Amount to shift the distribution by. There will be no values smaller
than this shift when sampling from the distribution.</p>
</dd>
<dt><strong>high</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: np.inf)</span></dt>
<dd><p class="first last">All values larger than or equal to this value will be clipped to
slightly less than this value.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.UniformHypersphere">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">UniformHypersphere</code><span class="sig-paren">(</span><em>surface=False</em>, <em>min_magnitude=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#UniformHypersphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.UniformHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniform distribution on or in an n-dimensional unit hypersphere.</p>
<p>Sample points are uniformly distributed across the volume (default) or
surface of an n-dimensional unit hypersphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>surface</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">Whether sample points should be distributed uniformly
over the surface of the hyperphere (True),
or within the hypersphere (False).</p>
</dd>
<dt><strong>min_magnitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Number, optional (Default: 0)</span></dt>
<dd><p class="first last">Lower bound on the returned vector magnitudes (such that they are in
the range <code class="docutils literal"><span class="pre">[min_magnitude,</span> <span class="pre">1]</span></code>). Must be in the range [0, 1).
Ignored if <code class="docutils literal"><span class="pre">surface</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Choice">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Choice</code><span class="sig-paren">(</span><em>options</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Choice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Choice" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete distribution across a set of possible values.</p>
<p>The same as <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.choice.html#numpy.random.choice" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.choice</span></code></a>, except can take vector or matrix values
for the choices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, …) array_like</span></dt>
<dd><p class="first last">The options (choices) to choose between. The choice is always done
along the first axis, so if <code class="xref py py-obj docutils literal"><span class="pre">options</span></code> is a matrix, the options are
the rows of that matrix.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N,) array_like, optional (Default: None)</span></dt>
<dd><p class="first last">Weights controlling the probability of selecting each option. Will
automatically be normalized. If None, weights be uniformly distributed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.Samples">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">Samples</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#Samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of samples.</p>
<p>This class is a subclass of <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">Distribution</span></code></a> so that it can be used in any
situation that calls for a  <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal"><span class="pre">Distribution</span></code></a>. However, the call to <a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal"><span class="pre">sample</span></code></a>
must match the dimensions of the samples or a <code class="xref py py-obj docutils literal"><span class="pre">ValidationError</span></code>
will be raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n, d) array_like</span></dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">n</span></code> and <code class="docutils literal"><span class="pre">d</span></code> must match what is eventually passed to <a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal"><span class="pre">sample</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.PDF">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">PDF</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#PDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.PDF" title="Permalink to this definition">¶</a></dt>
<dd><p>An arbitrary distribution from a PDF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">vector_like (n,)</span></dt>
<dd><p class="first last">Values of the points to sample from (interpolated).</p>
</dd>
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">vector_like (n,)</span></dt>
<dd><p class="first last">Probabilities of the <code class="xref py py-obj docutils literal"><span class="pre">x</span></code> points.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.SqrtBeta">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">SqrtBeta</code><span class="sig-paren">(</span><em>n</em>, <em>m=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the square root of a Beta distributed random variable.</p>
<p>Given <code class="docutils literal"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></code> dimensional random unit vectors, the length of subvectors
with <code class="docutils literal"><span class="pre">m</span></code> elements will be distributed according to this distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n: int</strong></dt>
<dd><p class="first last">Number of subvectors.</p>
</dd>
<dt><strong>m: int, optional (Default: 1)</strong></dt>
<dd><p class="first last">Length of each subvector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SubvectorLength</span></code></a></p>
</div>
<dl class="method">
<dt id="nengo.dists.SqrtBeta.cdf">
<code class="descname">cdf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.cdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires SciPy.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Evaluation points in [0, 1].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cdf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Probability that <code class="xref py py-obj docutils literal"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.pdf">
<code class="descname">pdf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.pdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability distribution function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires SciPy.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Evaluation points in [0, 1].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pdf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Probability density at <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.dists.SqrtBeta.ppf">
<code class="descname">ppf</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SqrtBeta.ppf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.ppf" title="Permalink to this definition">¶</a></dt>
<dd><p>Percent point function (inverse cumulative distribution).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires SciPy.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Cumulative probabilities in [0, 1].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ppf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Evaluation points <code class="docutils literal"><span class="pre">x</span></code> in [0, 1] such that <code class="docutils literal"><span class="pre">P(X</span> <span class="pre">&lt;=</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.dists.SubvectorLength">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">SubvectorLength</code><span class="sig-paren">(</span><em>dimensions</em>, <em>subdimensions=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#SubvectorLength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SubvectorLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the length of a subvectors of a unit vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dimensions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimensionality of the complete unit vector.</p>
</dd>
<dt><strong>subdimensions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: 1)</span></dt>
<dd><p class="first last">Dimensionality of the subvector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SqrtBeta</span></code></a></p>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.dists.CosineSimilarity">
<em class="property">class </em><code class="descclassname">nengo.dists.</code><code class="descname">CosineSimilarity</code><span class="sig-paren">(</span><em>dimensions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/dists.html#CosineSimilarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the cosine of the angle between two random vectors.</p>
<p>The “cosine similarity” is the cosine of the angle between two vectors,
which is equal to the dot product of the vectors, divided by the L2-norms
of the individual vectors. When these vectors are unit length, this is then
simply the distribution of their dot product.</p>
<p>This is also equivalent to the distribution of a single coefficient from a
unit vector (a single dimension of <code class="docutils literal"><span class="pre">UniformHypersphere(surface=True)</span></code>).
Furthermore, <code class="docutils literal"><span class="pre">CosineSimilarity(d+2)</span></code> is equivalent to the distribution of
a single coordinate from points uniformly sampled from the d-dimensional
unit ball (a single dimension of
<code class="docutils literal"><span class="pre">UniformHypersphere(surface=False).sample(n,</span> <span class="pre">d)</span></code>). These relationships
have been detailed in <a class="reference internal" href="#r0dd7d02f1d08-voelker2017" id="id1">[Voelker2017]</a>.</p>
<p>This can be used to calculate an intercept <code class="docutils literal"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> such that
<code class="docutils literal"><span class="pre">dot(u,</span> <span class="pre">v)</span> <span class="pre">&gt;=</span> <span class="pre">c</span></code> with probability <code class="docutils literal"><span class="pre">p</span></code>, for random unit vectors <code class="docutils literal"><span class="pre">u</span></code>
and <code class="docutils literal"><span class="pre">v</span></code>. In other words, a neuron with intercept <code class="docutils literal"><span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> will
fire with probability <code class="docutils literal"><span class="pre">p</span></code> for a random unit length input.</p>
<table class="docutils citation" frame="void" id="r0dd7d02f1d08-voelker2017" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Voelker2017]</a></td><td><a class="reference external" href="http://compneuro.uwaterloo.ca/publications/voelker2017.html">Aaron R. Voelker, Jan Gosmann, and Terrence C. Stewart.
Efficiently sampling vectors and coordinates from the n-sphere and
n-ball. Technical Report, Centre for Theoretical Neuroscience,
Waterloo, ON, 2017</a></td></tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dimensions: int</strong></dt>
<dd><p class="first last">Dimensionality of the complete unit vector.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal"><span class="pre">nengo.dists.SqrtBeta</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="neuron-types">
<h2>Neuron types<a class="headerlink" href="#neuron-types" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal"><span class="pre">nengo.neurons.NeuronType</span></code></a></td>
<td>Base class for Nengo neuron models.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Direct</span></code></a></td>
<td>Signifies that an ensemble should simulate in direct mode.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.RectifiedLinear" title="nengo.RectifiedLinear"><code class="xref py py-obj docutils literal"><span class="pre">nengo.RectifiedLinear</span></code></a></td>
<td>A rectified linear neuron model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.SpikingRectifiedLinear" title="nengo.SpikingRectifiedLinear"><code class="xref py py-obj docutils literal"><span class="pre">nengo.SpikingRectifiedLinear</span></code></a></td>
<td>A rectified integrate and fire neuron model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Sigmoid" title="nengo.Sigmoid"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Sigmoid</span></code></a></td>
<td>A neuron model whose response curve is a sigmoid.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.LIF" title="nengo.LIF"><code class="xref py py-obj docutils literal"><span class="pre">nengo.LIF</span></code></a></td>
<td>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.LIFRate" title="nengo.LIFRate"><code class="xref py py-obj docutils literal"><span class="pre">nengo.LIFRate</span></code></a></td>
<td>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.AdaptiveLIF" title="nengo.AdaptiveLIF"><code class="xref py py-obj docutils literal"><span class="pre">nengo.AdaptiveLIF</span></code></a></td>
<td>Adaptive spiking version of the LIF neuron model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.AdaptiveLIFRate" title="nengo.AdaptiveLIFRate"><code class="xref py py-obj docutils literal"><span class="pre">nengo.AdaptiveLIFRate</span></code></a></td>
<td>Adaptive non-spiking version of the LIF neuron model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Izhikevich" title="nengo.Izhikevich"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Izhikevich</span></code></a></td>
<td>Izhikevich neuron model.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.neurons.NeuronType">
<em class="property">class </em><code class="descclassname">nengo.neurons.</code><code class="descname">NeuronType</code><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for Nengo neuron models.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>probeable</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Signals that can be probed in the neuron population.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.neurons.NeuronType.current">
<code class="descname">current</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute current injected in each neuron given input, gain and bias.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Vector-space input.</p>
</dd>
<dt><strong>gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Bias current associated with each neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gain and bias needed to satisfy max_rates, intercepts.</p>
<p>This takes the neurons, approximates their response function, and then
uses that approximation to find the gain and bias value that will give
the requested intercepts and max_rates.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>max_rates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">X-intercepts of neurons.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Bias current associated with each neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max_rates and intercepts given gain and bias.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Bias current associated with each neuron.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>max_rates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">X-intercepts of neurons.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute firing rates (in Hz) for given vector input, <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>This default implementation takes the naive approach of running the
step function for a second. This should suffice for most rate-based
neuron types; for spiking neurons it will likely fail (those models
should override this function).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Vector-space input.</p>
</dd>
<dt><strong>gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Bias current associated with each neuron.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) ndarray</span></dt>
<dd><p class="first last">The firing rates at each given value of <code class="xref py py-obj docutils literal"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.neurons.NeuronType.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#NeuronType.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Simulation timestep.</p>
</dd>
<dt><strong>J</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons,) array_like</span></dt>
<dd><p class="first last">Output activities associated with each neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Direct">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Direct</code><a class="reference internal" href="_modules/nengo/neurons.html#Direct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Signifies that an ensemble should simulate in direct mode.</p>
<p>In direct mode, the ensemble represents and transforms signals perfectly,
rather than through a neural approximation. Note that direct mode ensembles
with recurrent connections can easily diverge; most other neuron types will
instead saturate at a certain high firing rate.</p>
<dl class="method">
<dt id="nengo.Direct.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Direct.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Direct.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if called.</p>
<p>Rather than calling this function, the simulator will detect that
the ensemble is in direct mode, and bypass the neural approximation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.RectifiedLinear">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">RectifiedLinear</code><span class="sig-paren">(</span><em>amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified linear neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless it passes below zero, at which point
the neural activity will stay at zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>amplitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output of the neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.RectifiedLinear.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine gain and bias by shifting and scaling the lines.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.RectifiedLinear.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.RectifiedLinear.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#RectifiedLinear.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the rectification nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.SpikingRectifiedLinear">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">SpikingRectifiedLinear</code><span class="sig-paren">(</span><em>amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#SpikingRectifiedLinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified integrate and fire neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless the current is less than zero, at
which point the neural activity will stay at zero. This is a spiking
version of the RectifiedLinear neuron model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>amplitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.SpikingRectifiedLinear.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#SpikingRectifiedLinear.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Use RectifiedLinear to determine rates.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.SpikingRectifiedLinear.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>spiked</em>, <em>voltage</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#SpikingRectifiedLinear.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the integrate and fire nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Sigmoid">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Sigmoid</code><span class="sig-paren">(</span><em>tau_ref=0.0025</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>A neuron model whose response curve is a sigmoid.</p>
<p>Since the tuning curves are strictly positive, the <code class="docutils literal"><span class="pre">intercepts</span></code>
correspond to the inflection point of each sigmoid. That is,
<code class="docutils literal"><span class="pre">f(intercept)</span> <span class="pre">=</span> <span class="pre">0.5</span></code> where <code class="docutils literal"><span class="pre">f</span></code> is the pure sigmoid function.</p>
<dl class="method">
<dt id="nengo.Sigmoid.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Sigmoid.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Sigmoid.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Sigmoid.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the sigmoid nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.LIF">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">LIF</code><span class="sig-paren">(</span><em>tau_rc=0.02</em>, <em>tau_ref=0.002</em>, <em>min_voltage=0</em>, <em>amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau_rc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>min_voltage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum value for the membrane voltage. If <code class="docutils literal"><span class="pre">-np.inf</span></code>, the voltage
is never clipped.</p>
</dd>
<dt><strong>amplitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.LIFRate">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">LIFRate</code><span class="sig-paren">(</span><em>tau_rc=0.02</em>, <em>tau_ref=0.002</em>, <em>amplitude=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau_rc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>amplitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.LIFRate.gain_bias">
<code class="descname">gain_bias</code><span class="sig-paren">(</span><em>max_rates</em>, <em>intercepts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.gain_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.max_rates_intercepts">
<code class="descname">max_rates_intercepts</code><span class="sig-paren">(</span><em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.max_rates_intercepts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always use LIFRate to determine rates.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LIFRate.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#LIFRate.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the LIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.AdaptiveLIF">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">AdaptiveLIF</code><span class="sig-paren">(</span><em>tau_n=1</em>, <em>inc_n=0.01</em>, <em>**lif_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">n</span></code> is incremented by <code class="docutils literal"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau_n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</dd>
<dt><strong>inc_n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</dd>
<dt><strong>tau_rc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r77178e5e5e1c-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Koch, Christof. Biophysics of Computation: Information Processing
in Single Neurons. Oxford University Press, 1999. p. 339</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.AdaptiveLIF.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em>, <em>voltage</em>, <em>ref</em>, <em>adaptation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIF.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIF nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.AdaptiveLIFRate">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">AdaptiveLIFRate</code><span class="sig-paren">(</span><em>tau_n=1</em>, <em>inc_n=0.01</em>, <em>**lif_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIFRate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive non-spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">n</span></code> is incremented by <code class="docutils literal"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau_n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</dd>
<dt><strong>inc_n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</dd>
<dt><strong>tau_rc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2c73dd51a65a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Koch, Christof. Biophysics of Computation: Information Processing
in Single Neurons. Oxford University Press, 1999. p. 339</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.AdaptiveLIFRate.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>output</em>, <em>adaptation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#AdaptiveLIFRate.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Izhikevich">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Izhikevich</code><span class="sig-paren">(</span><em>tau_recovery=0.02</em>, <em>coupling=0.2</em>, <em>reset_voltage=-65.0</em>, <em>reset_recovery=8.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich" title="Permalink to this definition">¶</a></dt>
<dd><p>Izhikevich neuron model.</p>
<p>This implementation is based on the original paper <a class="reference internal" href="#re23bd9a90d80-1" id="id4">[1]</a>;
however, we rename some variables for clarity.
What was originally ‘v’ we term ‘voltage’, which represents the membrane
potential of each neuron. What was originally ‘u’ we term ‘recovery’,
which represents membrane recovery, “which accounts for the activation
of K+ ionic currents and inactivation of Na+ ionic currents.”
The ‘a’, ‘b’, ‘c’, and ‘d’ parameters are also renamed
(see the parameters below).</p>
<p>We use default values that correspond to regular spiking (‘RS’) neurons.
For other classes of neurons, set the parameters as follows.</p>
<ul class="simple">
<li>Intrinsically bursting (IB): <code class="docutils literal"><span class="pre">reset_voltage=-55,</span> <span class="pre">reset_recovery=4</span></code></li>
<li>Chattering (CH): <code class="docutils literal"><span class="pre">reset_voltage=-50,</span> <span class="pre">reset_recovery=2</span></code></li>
<li>Fast spiking (FS): <code class="docutils literal"><span class="pre">tau_recovery=0.1</span></code></li>
<li>Low-threshold spiking (LTS): <code class="docutils literal"><span class="pre">coupling=0.25</span></code></li>
<li>Resonator (RZ): <code class="docutils literal"><span class="pre">tau_recovery=0.1,</span> <span class="pre">coupling=0.26</span></code></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau_recovery</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.02)</span></dt>
<dd><p class="first last">(Originally ‘a’) Time scale of the recovery variable.</p>
</dd>
<dt><strong>coupling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.2)</span></dt>
<dd><p class="first last">(Originally ‘b’) How sensitive recovery is to subthreshold
fluctuations of voltage.</p>
</dd>
<dt><strong>reset_voltage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: -65.)</span></dt>
<dd><p class="first last">(Originally ‘c’) The voltage to reset to after a spike, in millivolts.</p>
</dd>
<dt><strong>reset_recovery</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 8.)</span></dt>
<dd><p class="first last">(Originally ‘d’) The recovery value to reset to after a spike.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="re23bd9a90d80-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> E. M. Izhikevich, “Simple model of spiking neurons.”
IEEE Transactions on Neural Networks, vol. 14, no. 6, pp. 1569-1572.
(<a class="reference external" href="http://www.izhikevich.org/publications/spikes.pdf">http://www.izhikevich.org/publications/spikes.pdf</a>)</td></tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Izhikevich.rates">
<code class="descname">rates</code><span class="sig-paren">(</span><em>x</em>, <em>gain</em>, <em>bias</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich.rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates steady-state firing rate given gain and bias.</p>
<p>Uses the <code class="xref py py-obj docutils literal"><span class="pre">settled_firingrate</span></code> helper function.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.Izhikevich.step_math">
<code class="descname">step_math</code><span class="sig-paren">(</span><em>dt</em>, <em>J</em>, <em>spiked</em>, <em>voltage</em>, <em>recovery</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/neurons.html#Izhikevich.step_math"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.step_math" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the Izhikevich nonlinearity.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="learning-rule-types">
<h2>Learning rule types<a class="headerlink" href="#learning-rule-types" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.learning_rules.LearningRuleType" title="nengo.learning_rules.LearningRuleType"><code class="xref py py-obj docutils literal"><span class="pre">nengo.learning_rules.LearningRuleType</span></code></a></td>
<td>Base class for all learning rule objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal"><span class="pre">nengo.PES</span></code></a></td>
<td>Prescribed Error Sensitivity learning rule.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.BCM" title="nengo.BCM"><code class="xref py py-obj docutils literal"><span class="pre">nengo.BCM</span></code></a></td>
<td>Bienenstock-Cooper-Munroe learning rule.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Oja" title="nengo.Oja"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Oja</span></code></a></td>
<td>Oja learning rule.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Voja" title="nengo.Voja"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Voja</span></code></a></td>
<td>Vector Oja learning rule.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.learning_rules.LearningRuleType">
<em class="property">class </em><code class="descclassname">nengo.learning_rules.</code><code class="descname">LearningRuleType</code><span class="sig-paren">(</span><em>learning_rate=Default</em>, <em>size_in=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#LearningRuleType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.learning_rules.LearningRuleType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all learning rule objects.</p>
<p>To use a learning rule, pass it as a <code class="docutils literal"><span class="pre">learning_rule_type</span></code> keyword
argument to the <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal"><span class="pre">Connection</span></code></a> on which you want to do learning.</p>
<p>Each learning rule exposes two important pieces of metadata that the
builder uses to determine what information should be stored.</p>
<p>The <code class="docutils literal"><span class="pre">size_in</span></code> is the dimensionality of the incoming error signal. It
can either take an integer or one of the following string values:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'pre'</span></code>: vector error signal in pre-object space</li>
<li><code class="docutils literal"><span class="pre">'post'</span></code>: vector error signal in post-object space</li>
<li><code class="docutils literal"><span class="pre">'mid'</span></code>: vector error signal in the <code class="docutils literal"><span class="pre">conn.size_mid</span></code> space</li>
<li><code class="docutils literal"><span class="pre">'pre_state'</span></code>: vector error signal in pre-synaptic ensemble space</li>
<li><code class="docutils literal"><span class="pre">'post_state'</span></code>: vector error signal in pre-synaptic ensemble space</li>
</ul>
<p>The difference between <code class="docutils literal"><span class="pre">'post_state'</span></code> and <code class="docutils literal"><span class="pre">'post'</span></code> is that with the
former, if a <code class="docutils literal"><span class="pre">Neurons</span></code> object is passed, it will use the dimensionality
of the corresponding <code class="docutils literal"><span class="pre">Ensemble</span></code>, whereas the latter simply uses the
<code class="docutils literal"><span class="pre">post</span></code> object <code class="docutils literal"><span class="pre">size_in</span></code>. Similarly with <code class="docutils literal"><span class="pre">'pre_state'</span></code> and <code class="docutils literal"><span class="pre">'pre'</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">modifies</span></code> attribute denotes the signal targeted by the rule.
Options are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'encoders'</span></code></li>
<li><code class="docutils literal"><span class="pre">'decoders'</span></code></li>
<li><code class="docutils literal"><span class="pre">'weights'</span></code></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-6)</span></dt>
<dd><p class="first last">A scalar indicating the rate at which <code class="docutils literal"><span class="pre">modifies</span></code> will be adjusted.</p>
</dd>
<dt><strong>size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, str, optional (Default: 0)</span></dt>
<dd><p class="first last">Dimensionality of the error signal (see above).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A scalar indicating the rate at which <code class="docutils literal"><span class="pre">modifies</span></code> will be adjusted.</p>
</dd>
<dt><strong>size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, str</span></dt>
<dd><p class="first last">Dimensionality of the error signal.</p>
</dd>
<dt><strong>modifies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The signal targeted by the learning rule.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.PES">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">PES</code><span class="sig-paren">(</span><em>learning_rate=Default</em>, <em>pre_synapse=Default</em>, <em>pre_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#PES"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.PES" title="Permalink to this definition">¶</a></dt>
<dd><p>Prescribed Error Sensitivity learning rule.</p>
<p>Modifies a connection’s decoders to minimize an error signal provided
through a connection to the connection’s learning rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-4)</span></dt>
<dd><p class="first last">A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=0.005)</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.BCM">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">BCM</code><span class="sig-paren">(</span><em>learning_rate=Default</em>, <em>pre_synapse=Default</em>, <em>post_synapse=Default</em>, <em>theta_synapse=Default</em>, <em>pre_tau=Unconfigurable</em>, <em>post_tau=Unconfigurable</em>, <em>theta_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#BCM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.BCM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bienenstock-Cooper-Munroe learning rule.</p>
<p>Modifies connection weights as a function of the presynaptic activity
and the difference between the postsynaptic activity and the average
postsynaptic activity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-9)</span></dt>
<dd><p class="first last">A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=0.005)</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>post_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional (Default: <code class="docutils literal"><span class="pre">None</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the post-synaptic activities.
If None, <code class="docutils literal"><span class="pre">post_synapse</span></code> will be the same as <code class="docutils literal"><span class="pre">pre_synapse</span></code>.</p>
</dd>
<dt><strong>theta_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional                     (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=1.0)</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the theta signal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The BCM rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the BCM rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the BCM rule by <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the post-synaptic activities.</p>
</dd>
<dt><strong>pre_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>theta_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the theta signal.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.Oja">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Oja</code><span class="sig-paren">(</span><em>learning_rate=Default</em>, <em>pre_synapse=Default</em>, <em>post_synapse=Default</em>, <em>beta=Default</em>, <em>pre_tau=Unconfigurable</em>, <em>post_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#Oja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Oja" title="Permalink to this definition">¶</a></dt>
<dd><p>Oja learning rule.</p>
<p>Modifies connection weights according to the Hebbian Oja rule, which
augments typically Hebbian coactivity with a “forgetting” term that is
proportional to the weight of the connection and the square of the
postsynaptic activity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-6)</span></dt>
<dd><p class="first last">A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional                   (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=0.005)</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>post_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional (Default: <code class="docutils literal"><span class="pre">None</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the post-synaptic activities.
If None, <code class="docutils literal"><span class="pre">post_synapse</span></code> will be the same as <code class="docutils literal"><span class="pre">pre_synapse</span></code>.</p>
</dd>
<dt><strong>beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1.0)</span></dt>
<dd><p class="first last">A scalar weight on the forgetting term.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Oja rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the Oja rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the Oja rule by <code class="docutils literal"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A scalar weight on the forgetting term.</p>
</dd>
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the post-synaptic activities.</p>
</dd>
<dt><strong>pre_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.Voja">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Voja</code><span class="sig-paren">(</span><em>learning_rate=Default</em>, <em>post_synapse=Default</em>, <em>post_tau=Unconfigurable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/learning_rules.html#Voja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Voja" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector Oja learning rule.</p>
<p>Modifies an ensemble’s encoders to be selective to its inputs.</p>
<p>A connection to the learning rule will provide a scalar weight for the
learning rate, minus 1. For instance, 0 is normal learning, -1 is no
learning, and less than -1 causes anti-learning or “forgetting”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-2)</span></dt>
<dd><p class="first last">A scalar indicating the rate at which encoders will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a>, optional                    (Default: <code class="docutils literal"><span class="pre">nengo.synapses.Lowpass(tau=0.005)</span></code>)</span></dt>
<dd><p class="first last">Synapse model used to filter the post-synaptic activities.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>learning_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A scalar indicating the rate at which encoders will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">Synapse</span></code></a></span></dt>
<dd><p class="first last">Synapse model used to filter the post-synaptic activities.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="processes">
<h2>Processes<a class="headerlink" href="#processes" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Process</span></code></a></td>
<td>A general system with input, output, and state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.processes.PresentInput" title="nengo.processes.PresentInput"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.PresentInput</span></code></a></td>
<td>Present a series of inputs, each for the same fixed length of time.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.processes.FilteredNoise" title="nengo.processes.FilteredNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.FilteredNoise</span></code></a></td>
<td>Filtered white noise process.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.processes.BrownNoise" title="nengo.processes.BrownNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.BrownNoise</span></code></a></td>
<td>Brown noise process (aka Brownian noise, red noise, Wiener process).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.processes.WhiteNoise" title="nengo.processes.WhiteNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.WhiteNoise</span></code></a></td>
<td>Full-spectrum white noise process.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.processes.WhiteSignal" title="nengo.processes.WhiteSignal"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.WhiteSignal</span></code></a></td>
<td>An ideal low-pass filtered white noise process.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.processes.Piecewise" title="nengo.processes.Piecewise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.processes.Piecewise</span></code></a></td>
<td>A piecewise function with different options for interpolation.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.Process">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Process</code><span class="sig-paren">(</span><em>default_size_in=0</em>, <em>default_size_out=1</em>, <em>default_dt=0.001</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>A general system with input, output, and state.</p>
<p>For more details on how to use processes and make
custom process subclasses, see <a class="reference internal" href="examples/advanced/processes.html"><span class="doc">Processes and how to use them</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>default_size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (Default: 0)</span></dt>
<dd><p class="first last">Sets the default size in for nodes using this process.</p>
</dd>
<dt><strong>default_size_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (Default: 1)</span></dt>
<dd><p class="first last">Sets the default size out for nodes running this process. Also,
if <code class="docutils literal"><span class="pre">d</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</dd>
<dt><strong>default_dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (Default: 0.001 (1 millisecond))</span></dt>
<dd><p class="first last">If <code class="docutils literal"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal"><span class="pre">trange</span></code></a>, this will be used.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>default_dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">If <code class="docutils literal"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal"><span class="pre">trange</span></code></a>, this will be used.</p>
</dd>
<dt><strong>default_size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The default size in for nodes using this process.</p>
</dd>
<dt><strong>default_size_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The default size out for nodes running this process. Also, if <code class="docutils literal"><span class="pre">d</span></code> is
not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Process.apply">
<code class="descname">apply</code><span class="sig-paren">(</span><em>x</em>, <em>d=None</em>, <em>dt=None</em>, <em>rng=&lt;module 'numpy.random' from 'd:\\miniconda3\\envs\\nengo\\lib\\site-packages\\numpy\\random\\__init__.py'&gt;</em>, <em>copy=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.apply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process on a given input.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal"><span class="pre">make_step</span></code> function of this process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The input signal given to the process.</p>
</dd>
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Output dimensionality. If None, <code class="docutils literal"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a> (Default: <code class="docutils literal"><span class="pre">numpy.random</span></code>)</span></dt>
<dd><p class="first last">Random number generator used for stochstic processes.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: True)</span></dt>
<dd><p class="first last">If True, a new output array will be created for output.
If False, the input signal <code class="docutils literal"><span class="pre">x</span></code> will be overwritten.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.get_rng">
<code class="descname">get_rng</code><span class="sig-paren">(</span><em>rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.get_rng"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.get_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a properly seeded independent RNG for the process step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a></span></dt>
<dd><p class="first last">The parent random number generator to use if the seed is not set.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The simulation timestep.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a></span></dt>
<dd><p class="first last">A random number generator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>t</em>, <em>d=None</em>, <em>dt=None</em>, <em>rng=&lt;module 'numpy.random' from 'd:\\miniconda3\\envs\\nengo\\lib\\site-packages\\numpy\\random\\__init__.py'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given length of time.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal"><span class="pre">make_step</span></code> function of this process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The length of time to run.</p>
</dd>
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Output dimensionality. If None, <code class="docutils literal"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a> (Default: <code class="docutils literal"><span class="pre">numpy.random</span></code>)</span></dt>
<dd><p class="first last">Random number generator used for stochstic processes.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.run_steps">
<code class="descname">run_steps</code><span class="sig-paren">(</span><em>n_steps</em>, <em>d=None</em>, <em>dt=None</em>, <em>rng=&lt;module 'numpy.random' from 'd:\\miniconda3\\envs\\nengo\\lib\\site-packages\\numpy\\random\\__init__.py'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.run_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given number of steps.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal"><span class="pre">make_step</span></code> function of this process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of steps to run.</p>
</dd>
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Output dimensionality. If None, <code class="docutils literal"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a> (Default: <code class="docutils literal"><span class="pre">numpy.random</span></code>)</span></dt>
<dd><p class="first last">Random number generator used for stochstic processes.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.ntrange">
<code class="descname">ntrange</code><span class="sig-paren">(</span><em>n_steps</em>, <em>dt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.ntrange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.ntrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given number of steps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The given number of steps.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.Process.trange">
<code class="descname">trange</code><span class="sig-paren">(</span><em>t</em>, <em>dt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/base.html#Process.trange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.trange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given length of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The given length of time.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Simulation timestep. If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.processes.PresentInput">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">PresentInput</code><span class="sig-paren">(</span><em>inputs</em>, <em>presentation_time</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#PresentInput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PresentInput" title="Permalink to this definition">¶</a></dt>
<dd><p>Present a series of inputs, each for the same fixed length of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inputs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Inputs to present, where each row is an input. Rows will be flattened.</p>
</dd>
<dt><strong>presentation_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Show each input for this amount of time (in seconds).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.FilteredNoise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">FilteredNoise</code><span class="sig-paren">(</span><em>synapse=Lowpass(0.005)</em>, <em>dist=Gaussian(mean=0</em>, <em>std=1)</em>, <em>scale=True</em>, <em>synapse_kwargs=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#FilteredNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Filtered white noise process.</p>
<p>This process takes white noise and filters it using the provided synapse.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>synapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Synapse, optional (Default: <code class="docutils literal"><span class="pre">Lowpass(tau=0.005)</span></code>)</span></dt>
<dd><p class="first last">The synapse to use to filter the noise.</p>
</dd>
<dt><strong>dist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution, optional (Default: <code class="docutils literal"><span class="pre">Gaussian(mean=0,</span> <span class="pre">std=1)</span></code>)</span></dt>
<dd><p class="first last">The distribution used to generate the white noise.</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: True)</span></dt>
<dd><p class="first last">Whether to scale the white noise for integration, making the output
signal invariant to <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>synapse_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional (Default: None)</span></dt>
<dd><p class="first last">Arguments to pass to <code class="docutils literal"><span class="pre">synapse.make_step</span></code>.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.BrownNoise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">BrownNoise</code><span class="sig-paren">(</span><em>dist=Gaussian(mean=0</em>, <em>std=1)</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#BrownNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.BrownNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Brown noise process (aka Brownian noise, red noise, Wiener process).</p>
<p>This process is the integral of white noise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution, optional (Default: <code class="docutils literal"><span class="pre">Gaussian(mean=0,</span> <span class="pre">std=1)</span></code>)</span></dt>
<dd><p class="first last">The distribution used to generate the white noise.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.WhiteNoise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">WhiteNoise</code><span class="sig-paren">(</span><em>dist=Gaussian(mean=0</em>, <em>std=1)</em>, <em>scale=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Full-spectrum white noise process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distribution, optional (Default: <code class="docutils literal"><span class="pre">Gaussian(mean=0,</span> <span class="pre">std=1)</span></code>)</span></dt>
<dd><p class="first last">The distribution from which to draw samples.</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: True)</span></dt>
<dd><p class="first last">Whether to scale the white noise for integration. Integrating white
noise requires using a time constant of <code class="docutils literal"><span class="pre">sqrt(dt)</span></code> instead of <code class="docutils literal"><span class="pre">dt</span></code>
on the noise term <a class="reference internal" href="#rd2dd8a36bd47-1" id="id6">[1]</a>, to ensure the magnitude of the integrated
noise does not change with <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd2dd8a36bd47-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> Gillespie, D.T. (1996) Exact numerical simulation of the Ornstein-
Uhlenbeck process and its integral. Phys. Rev. E 54, pp. 2084-91.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.WhiteSignal">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">WhiteSignal</code><span class="sig-paren">(</span><em>period</em>, <em>high</em>, <em>rms=0.5</em>, <em>y0=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#WhiteSignal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>An ideal low-pass filtered white noise process.</p>
<p>This signal is created in the frequency domain, and designed to have
exactly equal power at all frequencies below the cut-off frequency,
and no power above the cut-off.</p>
<p>The signal is naturally periodic, so it can be used beyond its period
while still being continuous with continuous derivatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>period</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A white noise signal with this period will be generated.
Samples will repeat after this duration.</p>
</dd>
<dt><strong>high</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The cut-off frequency of the low-pass filter, in Hz.
Must not exceed the Nyquist frequency for the simulation
timestep, which is <code class="docutils literal"><span class="pre">0.5</span> <span class="pre">/</span> <span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>rms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.5)</span></dt>
<dd><p class="first last">The root mean square power of the filtered signal</p>
</dd>
<dt><strong>y0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">Align the phase of each output dimension to begin at the value
that is closest (in absolute value) to y0.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.processes.Piecewise">
<em class="property">class </em><code class="descclassname">nengo.processes.</code><code class="descname">Piecewise</code><span class="sig-paren">(</span><em>data</em>, <em>interpolation='zero'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/processes.html#Piecewise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.Piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>A piecewise function with different options for interpolation.</p>
<p>Given an input dictionary of <code class="docutils literal"><span class="pre">{0:</span> <span class="pre">0,</span> <span class="pre">0.5:</span> <span class="pre">-1,</span> <span class="pre">0.75:</span> <span class="pre">0.5,</span> <span class="pre">1:</span> <span class="pre">0}</span></code>,
this process  will emit the numerical values (0, -1, 0.5, 0)
starting at the corresponding time points (0, 0.5, 0.75, 1).</p>
<p>The keys in the input dictionary must be times (float or int).
The values in the dictionary can be floats, lists of floats,
or numpy arrays. All lists or numpy arrays must be of the same length,
as the output shape of the process will be determined by the shape
of the values.</p>
<p>Interpolation on the data points using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.1.0)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></code></a> is also
supported. The default interpolation is ‘zero’, which creates a
piecewise function whose values change at the specified time points.
So the above example would be shortcut for:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.75</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>For times before the first specified time, an array of zeros (of
the correct length) will be emitted.
This means that the above can be simplified to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary mapping times to the values that should be emitted
at those times. Times must be numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional (Default: ‘zero’)</span></dt>
<dd><p class="first last">One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values begin at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.1.0)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nengo.processes</span> <span class="k">import</span> <span class="n">Piecewise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">process</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">u</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">size_out</span><span class="o">=</span><span class="n">process</span><span class="o">.</span><span class="n">default_size_out</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">up</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">up</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="go">array([[ 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.58</span><span class="p">]</span>
<span class="go">array([[ 1.]])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary mapping times to the values that should be emitted
at those times. Times are numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values change at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.1.0)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="synapse-models">
<h2>Synapse models<a class="headerlink" href="#synapse-models" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.Synapse</span></code></a></td>
<td>Abstract base class for synapse models.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.synapses.filt" title="nengo.synapses.filt"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.filt</span></code></a></td>
<td>Filter <code class="docutils literal"><span class="pre">signal</span></code> with <code class="docutils literal"><span class="pre">synapse</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.synapses.filtfilt" title="nengo.synapses.filtfilt"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.filtfilt</span></code></a></td>
<td>Zero-phase filtering of <code class="docutils literal"><span class="pre">signal</span></code> using the <code class="docutils literal"><span class="pre">synapse</span></code> filter.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.LinearFilter" title="nengo.LinearFilter"><code class="xref py py-obj docutils literal"><span class="pre">nengo.LinearFilter</span></code></a></td>
<td>General linear time-invariant (LTI) system synapse.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.Lowpass" title="nengo.Lowpass"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Lowpass</span></code></a></td>
<td>Standard first-order lowpass filter synapse.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.Alpha" title="nengo.Alpha"><code class="xref py py-obj docutils literal"><span class="pre">nengo.Alpha</span></code></a></td>
<td>Alpha-function filter synapse.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.synapses.Triangle" title="nengo.synapses.Triangle"><code class="xref py py-obj docutils literal"><span class="pre">nengo.synapses.Triangle</span></code></a></td>
<td>Triangular finite impulse response (FIR) synapse.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.synapses.Synapse">
<em class="property">class </em><code class="descclassname">nengo.synapses.</code><code class="descname">Synapse</code><span class="sig-paren">(</span><em>default_size_in=1</em>, <em>default_size_out=None</em>, <em>default_dt=0.001</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for synapse models.</p>
<p>Conceptually, a synapse model emulates a biological synapse, taking in
input in the form of released neurotransmitter and opening ion channels
to allow more or less current to flow into the neuron.</p>
<p>In Nengo, the implementation of a synapse is as a specific case of a
<a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal"><span class="pre">Process</span></code></a> in which the input and output shapes are the same.
The input is the current across the synapse, and the output is the current
that will be induced in the postsynaptic neuron.</p>
<p>Synapses also contain the <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filt</span></code></a> and <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filtfilt</span></code></a> methods,
which make it easy to use Nengo’s synapse models outside of Nengo
simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>default_size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: 1)</span></dt>
<dd><p class="first last">The size_in used if not specified.</p>
</dd>
<dt><strong>default_size_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (Default: None)</span></dt>
<dd><p class="first last">The size_out used if not specified.
If None, will be the same as default_size_in.</p>
</dd>
<dt><strong>default_dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (Default: 0.001 (1 millisecond))</span></dt>
<dd><p class="first last">The simulation timestep used if not specified.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>default_dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (Default: 0.001 (1 millisecond))</span></dt>
<dd><p class="first last">The simulation timestep used if not specified.</p>
</dd>
<dt><strong>default_size_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (Default: 0)</span></dt>
<dd><p class="first last">The size_in used if not specified.</p>
</dd>
<dt><strong>default_size_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (Default: 1)</span></dt>
<dd><p class="first last">The size_out used if not specified.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: None)</span></dt>
<dd><p class="first last">Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.synapses.Synapse.filt">
<code class="descname">filt</code><span class="sig-paren">(</span><em>x</em>, <em>dt=None</em>, <em>axis=0</em>, <em>y0=None</em>, <em>copy=True</em>, <em>filtfilt=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.filt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal"><span class="pre">x</span></code> with this synapse model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">The signal to filter.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: None)</span></dt>
<dd><p class="first last">The timestep of the input signal.
If None, <code class="docutils literal"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional (Default: 0)</span></dt>
<dd><p class="first last">The axis along which to filter.</p>
</dd>
<dt><strong>y0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional (Default: None)</span></dt>
<dd><p class="first last">The starting state of the filter output. If None, the initial
value of the input signal along the axis filtered will be used.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: True)</span></dt>
<dd><p class="first last">Whether to copy the input data, or simply work in-place.</p>
</dd>
<dt><strong>filtfilt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If True, runs the process forward then backward on the signal,
for zero-phase filtering (like Matlab’s <code class="docutils literal"><span class="pre">filtfilt</span></code>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.synapses.Synapse.filtfilt">
<code class="descname">filtfilt</code><span class="sig-paren">(</span><em>x</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal"><span class="pre">x</span></code> using this filter.</p>
<p>Equivalent to <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal"><span class="pre">filt(x,</span> <span class="pre">filtfilt=True,</span> <span class="pre">**kwargs)</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.synapses.Synapse.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Synapse.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the synapse forward one time step.</p>
<p>At a minimum, Synapse subclasses must implement this method.
That implementation should return a callable that will perform
the synaptic filtering operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shape_in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Shape of the input signal to be filtered.</p>
</dd>
<dt><strong>shape_out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Shape of the output filtered signal.</p>
</dd>
<dt><strong>dt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The timestep of the simulation.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a></span></dt>
<dd><p class="first last">Random number generator.</p>
</dd>
<dt><strong>y0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional (Default: None)</span></dt>
<dd><p class="first last">The starting state of the filter output. If None, each dimension
of the state will start at zero.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.dtype</span></code></a> (Default: np.float64)</span></dt>
<dd><p class="first last">Type of data used by the synapse model. This is important for
ensuring that certain synapses avoid or force integer division.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nengo.synapses.filt">
<code class="descclassname">nengo.synapses.</code><code class="descname">filt</code><span class="sig-paren">(</span><em>signal</em>, <em>synapse</em>, <em>dt</em>, <em>axis=0</em>, <em>x0=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#filt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal"><span class="pre">signal</span></code> with <code class="docutils literal"><span class="pre">synapse</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in Nengo 2.1.0.
Use <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filt</span></code></a> method instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="nengo.synapses.filtfilt">
<code class="descclassname">nengo.synapses.</code><code class="descname">filtfilt</code><span class="sig-paren">(</span><em>signal</em>, <em>synapse</em>, <em>dt</em>, <em>axis=0</em>, <em>x0=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#filtfilt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal"><span class="pre">signal</span></code> using the <code class="docutils literal"><span class="pre">synapse</span></code> filter.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in Nengo 2.1.0.
Use <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal"><span class="pre">Synapse.filtfilt</span></code></a> method instead.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">LinearFilter</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>analog=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>General linear time-invariant (LTI) system synapse.</p>
<p>This class can be used to implement any linear filter, given the
filter’s transfer function. <a class="reference internal" href="#r853643b3d554-1" id="id8">[1]</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>num</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Numerator coefficients of transfer function.</p>
</dd>
<dt><strong>den</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Denominator coefficients of transfer function.</p>
</dd>
<dt><strong>analog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (Default: True)</span></dt>
<dd><p class="first last">Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r853643b3d554-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Filter_%28signal_processing%29">https://en.wikipedia.org/wiki/Filter_%28signal_processing%29</a></td></tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>analog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>den</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Denominator coefficients of transfer function.</p>
</dd>
<dt><strong>num</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Numerator coefficients of transfer function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.LinearFilter.combine">
<code class="descname">combine</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.combine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine in series with another LinearFilter.</p>
</dd></dl>

<dl class="method">
<dt id="nengo.LinearFilter.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>frequencies</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transfer function at the given frequencies.</p>
<p class="rubric">Examples</p>
<p>Using the <code class="docutils literal"><span class="pre">evaluate</span></code> function to make a Bode plot:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">synapse</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">synapses</span><span class="o">.</span><span class="n">LinearFilter</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">synapse</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;magnitude [dB]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;phase [radians]&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nengo.LinearFilter.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>method='zoh'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal"><span class="pre">Step</span></code></a> instance that implements the linear filter.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.Step">
<em class="property">class </em><code class="descname">Step</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.Step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.Step" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for LTI filtering step functions.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.NoDen">
<em class="property">class </em><code class="descname">NoDen</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.NoDen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.NoDen" title="Permalink to this definition">¶</a></dt>
<dd><p>An LTI step function for transfer functions with no denominator.</p>
<p>This step function should be much faster than the equivalent general
step function.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.Simple">
<em class="property">class </em><code class="descname">Simple</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em>, <em>y0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.Simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.Simple" title="Permalink to this definition">¶</a></dt>
<dd><p>An LTI step function for transfer functions with one num and den.</p>
<p>This step function should be much faster than the equivalent general
step function.</p>
</dd></dl>

<dl class="class">
<dt id="nengo.LinearFilter.General">
<em class="property">class </em><code class="descname">General</code><span class="sig-paren">(</span><em>num</em>, <em>den</em>, <em>output</em>, <em>y0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#LinearFilter.General"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.General" title="Permalink to this definition">¶</a></dt>
<dd><p>An LTI step function for any given transfer function.</p>
<p>Implements a discrete-time LTI system using the difference equation
<a class="reference internal" href="#r2d071e7adb1a-1" id="id10">[1]</a> for the given transfer function (num, den).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2d071e7adb1a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Digital_filter#Difference_equation">https://en.wikipedia.org/wiki/Digital_filter#Difference_equation</a></td></tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Lowpass">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Lowpass</code><span class="sig-paren">(</span><em>tau</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Lowpass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Lowpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard first-order lowpass filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time constant of the filter in seconds.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time constant of the filter in seconds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Lowpass.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Lowpass.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Lowpass.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an optimized <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal"><span class="pre">LinearFilter.Step</span></code></a> subclass.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.Alpha">
<em class="property">class </em><code class="descclassname">nengo.</code><code class="descname">Alpha</code><span class="sig-paren">(</span><em>tau</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha-function filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">alpha</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<p>and was found by <a class="reference internal" href="#r2fca3e9f2935-1" id="id12">[1]</a> to be a good basic model for synapses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time constant of the filter in seconds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2fca3e9f2935-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id12">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> Mainen, Z.F. and Sejnowski, T.J. (1995). Reliability of spike timing
in neocortical neurons. Science (New York, NY), 268(5216):1503-6.</td></tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time constant of the filter in seconds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.Alpha.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Alpha.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Alpha.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an optimized <a class="reference internal" href="#nengo.LinearFilter.Step" title="nengo.LinearFilter.Step"><code class="xref py py-obj docutils literal"><span class="pre">LinearFilter.Step</span></code></a> subclass.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.synapses.Triangle">
<em class="property">class </em><code class="descclassname">nengo.synapses.</code><code class="descname">Triangle</code><span class="sig-paren">(</span><em>t</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Triangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular finite impulse response (FIR) synapse.</p>
<p>This synapse has a triangular and finite impulse response. The length of
the triangle is <code class="docutils literal"><span class="pre">t</span></code> seconds; thus the digital filter will have
<code class="docutils literal"><span class="pre">t</span> <span class="pre">/</span> <span class="pre">dt</span> <span class="pre">+</span> <span class="pre">1</span></code> taps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Length of the triangle, in seconds.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Length of the triangle, in seconds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nengo.synapses.Triangle.make_step">
<code class="descname">make_step</code><span class="sig-paren">(</span><em>shape_in</em>, <em>shape_out</em>, <em>dt</em>, <em>rng</em>, <em>y0=None</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/synapses.html#Triangle.make_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a custom step function.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="decoder-and-connection-weight-solvers">
<h2>Decoder and connection weight solvers<a class="headerlink" href="#decoder-and-connection-weight-solvers" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.Solver</span></code></a></td>
<td>Decoder or weight solver.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.Lstsq</span></code></a></td>
<td>Unregularized least-squares solver.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.LstsqNoise" title="nengo.solvers.LstsqNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqNoise</span></code></a></td>
<td>Least-squares solver with additive Gaussian white noise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.LstsqMultNoise" title="nengo.solvers.LstsqMultNoise"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqMultNoise</span></code></a></td>
<td>Least-squares solver with multiplicative white noise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqL2</span></code></a></td>
<td>Least-squares solver with L2 regularization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqL2nz</span></code></a></td>
<td>Least-squares solver with L2 regularization on non-zero components.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.LstsqL1" title="nengo.solvers.LstsqL1"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqL1</span></code></a></td>
<td>Least-squares solver with L1 and L2 regularization (elastic net).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.LstsqDrop" title="nengo.solvers.LstsqDrop"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.LstsqDrop</span></code></a></td>
<td>Find sparser decoders/weights by dropping small values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.Nnls" title="nengo.solvers.Nnls"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.Nnls</span></code></a></td>
<td>Non-negative least-squares solver without regularization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.NnlsL2" title="nengo.solvers.NnlsL2"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.NnlsL2</span></code></a></td>
<td>Non-negative least-squares solver with L2 regularization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#nengo.solvers.NnlsL2nz" title="nengo.solvers.NnlsL2nz"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.NnlsL2nz</span></code></a></td>
<td>Non-negative least-squares with L2 regularization on nonzero components.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#nengo.solvers.NoSolver" title="nengo.solvers.NoSolver"><code class="xref py py-obj docutils literal"><span class="pre">nengo.solvers.NoSolver</span></code></a></td>
<td>Manually pass in weights, bypassing the decoder solver.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="nengo.solvers.Solver">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">Solver</code><span class="sig-paren">(</span><em>weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Decoder or weight solver.</p>
<dl class="method">
<dt id="nengo.solvers.Solver.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>A</em>, <em>Y</em>, <em>rng=&lt;module 'numpy.random' from 'd:\\miniconda3\\envs\\nengo\\lib\\site-packages\\numpy\\random\\__init__.py'&gt;</em>, <em>E=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the solver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_eval_points, n_neurons) array_like</span></dt>
<dd><p class="first last">Matrix of the neurons’ activities at the evaluation points</p>
</dd>
<dt><strong>Y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_eval_points, dimensions) array_like</span></dt>
<dd><p class="first last">Matrix of the target decoded values for each of the D dimensions,
at each of the evaluation points.</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html#numpy.random.RandomState" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.random.RandomState</span></code></a>, optional (Default: <code class="xref py py-obj docutils literal"><span class="pre">np.random</span></code>)</span></dt>
<dd><p class="first last">A random number generator to use as required.</p>
</dd>
<dt><strong>E</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(dimensions, post.n_neurons) array_like, optional (Default: None)</span></dt>
<dd><p class="first last">Array of post-population encoders. Providing this tells the solver
to return an array of connection weights rather than decoders.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>X</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons, dimensions) or (n_neurons, post.n_neurons) ndarray</span></dt>
<dd><p class="first last">(n_neurons, dimensions) array of decoders (if <code class="docutils literal"><span class="pre">solver.weights</span></code>
is False) or (n_neurons, post.n_neurons) array of weights
(if <code class="docutils literal"><span class="pre">'solver.weights</span></code> is True).</p>
</dd>
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary of information about the solver. All dictionaries have
an <code class="docutils literal"><span class="pre">'rmses'</span></code> key that contains RMS errors of the solve.
Other keys are unique to particular solvers.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nengo.solvers.Solver.mul_encoders">
<code class="descname">mul_encoders</code><span class="sig-paren">(</span><em>Y</em>, <em>E</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Solver.mul_encoders"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver.mul_encoders" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that projects signal <code class="docutils literal"><span class="pre">Y</span></code> onto encoders <code class="docutils literal"><span class="pre">E</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The signal of interest.</p>
</dd>
<dt><strong>E</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(dimensions, n_neurons) array_like or None</span></dt>
<dd><p class="first last">Array of encoders. If None, <code class="docutils literal"><span class="pre">Y</span></code> will be returned unchanged.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">Whether a copy of <code class="docutils literal"><span class="pre">Y</span></code> should be returned if <code class="docutils literal"><span class="pre">E</span></code> is None.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nengo.solvers.Lstsq">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">Lstsq</code><span class="sig-paren">(</span><em>weights=False</em>, <em>rcond=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Lstsq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Lstsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregularized least-squares solver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>rcond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.01)</span></dt>
<dd><p class="first last">Cut-off ratio for small singular values (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rcond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Cut-off ratio for small singular values (see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.15)"><code class="xref py py-obj docutils literal"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqNoise">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqNoise</code><span class="sig-paren">(</span><em>weights=False</em>, <em>noise=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with additive Gaussian white noise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.1)</span></dt>
<dd><p class="first last">Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code></span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqMultNoise">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqMultNoise</code><span class="sig-paren">(</span><em>weights=False</em>, <em>noise=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqMultNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqMultNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with multiplicative white noise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.1)</span></dt>
<dd><p class="first last">Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code></span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL2">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqL2</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.1)</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code></span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL2nz">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqL2nz</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em>, <em>solver=Cholesky(transpose=None)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL2nz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization on non-zero components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.1)</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code>, optional (Default: <code class="docutils literal"><span class="pre">Cholesky()</span></code>)</span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-obj docutils literal"><span class="pre">LeastSquaresSolver</span></code></span></dt>
<dd><p class="first last">Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqL1">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqL1</code><span class="sig-paren">(</span><em>weights=False</em>, <em>l1=0.0001</em>, <em>l2=1e-06</em>, <em>max_iter=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqL1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L1 and L2 regularization (elastic net).</p>
<p>This method is well suited for creating sparse decoders or weight matrices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires <a class="reference external" href="http://scikit-learn.org/stable/">scikit-learn</a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>l1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-4)</span></dt>
<dd><p class="first last">Amount of L1 regularization.</p>
</dd>
<dt><strong>l2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 1e-6)</span></dt>
<dd><p class="first last">Amount of L2 regularization.</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of iterations for the underlying elastic net.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>l1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of L1 regularization.</p>
</dd>
<dt><strong>l2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of L2 regularization.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations for the underlying elastic net.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.LstsqDrop">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">LstsqDrop</code><span class="sig-paren">(</span><em>weights=False</em>, <em>drop=0.25</em>, <em>solver1=LstsqL2(reg=0.001</em>, <em>solver=Cholesky(transpose=None)</em>, <em>weights=False)</em>, <em>solver2=LstsqL2(reg=0.1</em>, <em>solver=Cholesky(transpose=None)</em>, <em>weights=False)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#LstsqDrop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Find sparser decoders/weights by dropping small values.</p>
<p>This solver first solves for coefficients (decoders/weights) with
L2 regularization, drops those nearest to zero, and retrains remaining.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>drop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.25)</span></dt>
<dd><p class="first last">Fraction of decoders or weights to set to zero.</p>
</dd>
<dt><strong>solver1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver, optional (Default: <code class="docutils literal"><span class="pre">LstsqL2(reg=0.001)</span></code>)</span></dt>
<dd><p class="first last">Solver for finding the initial decoders.</p>
</dd>
<dt><strong>solver2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver, optional (Default: <code class="docutils literal"><span class="pre">LstsqL2(reg=0.1)</span></code>)</span></dt>
<dd><p class="first last">Used for re-solving for the decoders after dropout.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>drop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fraction of decoders or weights to set to zero.</p>
</dd>
<dt><strong>solver1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver</span></dt>
<dd><p class="first last">Solver for finding the initial decoders.</p>
</dd>
<dt><strong>solver2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Solver</span></dt>
<dd><p class="first last">Used for re-solving for the decoders after dropout.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.Nnls">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">Nnls</code><span class="sig-paren">(</span><em>weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#Nnls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver without regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal"><span class="pre">Lstsq</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NnlsL2">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">NnlsL2</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NnlsL2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver with L2 regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal"><span class="pre">LstsqL2</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.1)</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NnlsL2nz">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">NnlsL2nz</code><span class="sig-paren">(</span><em>weights=False</em>, <em>reg=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NnlsL2nz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares with L2 regularization on nonzero components.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal"><span class="pre">LstsqL2nz</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional (Default: 0.1)</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="nengo.solvers.NoSolver">
<em class="property">class </em><code class="descclassname">nengo.solvers.</code><code class="descname">NoSolver</code><span class="sig-paren">(</span><em>values=None</em>, <em>weights=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nengo/solvers.html#NoSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NoSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually pass in weights, bypassing the decoder solver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons, n_weights) array_like, optional (Default: None)</span></dt>
<dd><p class="first last">The array of decoders or weights to use.
If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, <code class="docutils literal"><span class="pre">n_weights</span></code> is the expected
output dimensionality. If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">True</span></code>,
<code class="docutils literal"><span class="pre">n_weights</span></code> is the number of neurons in the post ensemble.
If <code class="docutils literal"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as decoders.
If True, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as weights.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(n_neurons, n_weights) array_like, optional (Default: None)</span></dt>
<dd><p class="first last">The array of decoders or weights to use.
If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, <code class="docutils literal"><span class="pre">n_weights</span></code> is the expected
output dimensionality. If <code class="docutils literal"><span class="pre">weights</span></code> is <code class="docutils literal"><span class="pre">True</span></code>,
<code class="docutils literal"><span class="pre">n_weights</span></code> is the number of neurons in the post ensemble.
If <code class="docutils literal"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional (Default: False)</span></dt>
<dd><p class="first last">If False, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as decoders.
If True, <code class="docutils literal"><span class="pre">values</span></code> is interpreted as weights.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="user_guide.html" title="previous chapter (use the left arrow)">User guide</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="config.html" title="next chapter (use the right arrow)">Setting parameters with Configs</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="config.html" title="Setting parameters with Configs"
             >next</a> |</li>
        <li class="right" >
          <a href="user_guide.html" title="User guide"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Nengo core 2.8.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="user_guide.html" >User guide</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2013-2017, Applied Brain Research. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>
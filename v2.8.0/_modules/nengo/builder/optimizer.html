

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>nengo.builder.optimizer &#8212; Nengo core 2.8.0 docs</title>
    <link rel="stylesheet" href="../../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

<!-- Google Tag Manager -->
<script>
 (function (w, d, s, l, i) {
   w[l] = w[l] || [];
   w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
   var f = d.getElementsByTagName(s)[0],
       j = d.createElement(s),
       dl = l != "dataLayer" ? "&l=" + l : "";
   j.async = true;
   j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
   f.parentNode.insertBefore(j, f);
 })(window, document, "script", "dataLayer", "GTM-KWCR2HN");
</script>
<!-- End Google Tag Manager -->
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" type="text/css" href="../../../_static/custom.css">


  
   

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Nengo core 2.8.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
        <a href="
    ../../../index.html" class="text-logo">Nengo core 2.8</a>
        <div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing to Nengo</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.nengo.ai/projects.html">Nengo ecosystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">Nengo license</a></li>
</ul>

    
  </div>
</div>
        
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
    </div>
  </div>
        <div id="right-column">
          
  <div class="header">
    
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../../index.html">Docs</a></li>
              
                <li><a href="../../index.html">Module code</a></li>
              
              <li>nengo.builder.optimizer</li>
            </ol>
          </div>
          
    
  </div>

          <div class="document clearer body">
            
  <h1>Source code for nengo.builder.optimizer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Operator graph optimizers.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">nengo.builder.neurons</span> <span class="k">import</span> <span class="n">SimNeurons</span>
<span class="kn">from</span> <span class="nn">nengo.builder</span> <span class="k">import</span> <span class="n">operator</span>
<span class="kn">from</span> <span class="nn">nengo.builder.operator</span> <span class="k">import</span> <span class="n">DotInc</span><span class="p">,</span> <span class="n">ElementwiseInc</span><span class="p">,</span> <span class="n">Copy</span>
<span class="kn">from</span> <span class="nn">nengo.builder.signal</span> <span class="k">import</span> <span class="n">Signal</span>
<span class="kn">from</span> <span class="nn">nengo.utils.compat</span> <span class="k">import</span> <span class="n">iteritems</span><span class="p">,</span> <span class="n">itervalues</span><span class="p">,</span> <span class="n">zip_longest</span>
<span class="kn">from</span> <span class="nn">nengo.utils.graphs</span> <span class="k">import</span> <span class="n">BidirectionalDAG</span><span class="p">,</span> <span class="n">transitive_closure</span>
<span class="kn">from</span> <span class="nn">nengo.utils.stdlib</span> <span class="k">import</span> <span class="n">Timer</span><span class="p">,</span> <span class="n">WeakKeyDefaultDict</span><span class="p">,</span> <span class="n">WeakSet</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;optimize&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="optimize"><a class="viewcode-back" href="../../../backend_api.html#nengo.builder.optimizer.optimize">[docs]</a><span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dg</span><span class="p">,</span> <span class="n">max_passes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimizes the operator graph by merging operators.</span>

<span class="sd">    This reduces the number of iterators to iterate over in slow Python code</span>
<span class="sd">    (as opposed to fast C code). The resulting merged operators will also</span>
<span class="sd">    operate on larger chunks of sequential memory, making better use of CPU</span>
<span class="sd">    caching and prefetching.</span>

<span class="sd">    The optimization algorithm has worst case complexity :math:`O(n^2 + e)`,</span>
<span class="sd">    where :math:`n` is the number of operators and :math:`e` is the number</span>
<span class="sd">    of edges in the dependency graph. In practice the run time will be much</span>
<span class="sd">    better because not all :math:`n^2` pairwise combinations of operators</span>
<span class="sd">    will be evaluated. A grouping depending on the operator type and view</span>
<span class="sd">    bases is done with dictionaries. This grouping can be done in amortized</span>
<span class="sd">    linear time and reduces the actual worst-case runtime of the optimization</span>
<span class="sd">    algorithm to :math:`O(gm^2 + e)`, where :math:`g` is the number of groups</span>
<span class="sd">    and :math:`m` is the number of elements in a group. Moreover, information</span>
<span class="sd">    about memory alignment will be used to cut the inner loop short in</span>
<span class="sd">    many cases and gives a runtime much closer to linear in most cases.</span>

<span class="sd">    Note that this function modifies both ``model`` and ``dg``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : `nengo.builder.Model`</span>
<span class="sd">        Builder output to optimize.</span>
<span class="sd">    dg : dict</span>
<span class="sd">        Dict of the form ``{a: {b, c}}`` where ``b`` and ``c`` depend on ``a``,</span>
<span class="sd">        specifying the operator dependency graph of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Optimizing model...&quot;</span><span class="p">)</span>

    <span class="c1"># We try first to merge operators with views only as these have a fixed</span>
    <span class="c1"># order for the memory alignment whereas operators without views could</span>
    <span class="c1"># be merged in a random order. Merging the views of operators will</span>
    <span class="c1"># propagate requirements in the memory ordering via the other</span>
    <span class="c1"># associated signals of the operator to other operators.</span>

    <span class="c1"># Once no more operators with views can be merged, we try to merge</span>
    <span class="c1"># operators without views and then try again merging views (because</span>
    <span class="c1"># each operator merge might generate new views).</span>

    <span class="n">single_pass</span> <span class="o">=</span> <span class="n">OpMergePass</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>

    <span class="n">n_initial_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
    <span class="n">cum_duration</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">only_merge_ops_with_view</span> <span class="ow">or</span> <span class="n">after</span> <span class="o">&lt;</span> <span class="n">before</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">max_passes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">max_passes</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tp</span><span class="p">,</span> <span class="n">ops</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">groupby</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="nb">type</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>

        <span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="n">before</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">before</span> <span class="o">!=</span> <span class="n">after</span>
        <span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_pass</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">single_pass</span><span class="p">(</span><span class="n">only_merge_ops_with_view</span><span class="p">)</span>

        <span class="n">after</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">single_pass</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Pass </span><span class="si">%i</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">]: Reduced </span><span class="si">%i</span><span class="s2"> to </span><span class="si">%i</span><span class="s2"> operators in </span><span class="si">%f</span><span class="s2">s.&quot;</span><span class="p">,</span>
            <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;views&quot;</span> <span class="k">if</span> <span class="n">only_merge_ops_with_view</span> <span class="k">else</span> <span class="s2">&quot;non-views&quot;</span><span class="p">,</span>
            <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>

        <span class="c1"># Prevent optimizer from running too long if we get up diminishing</span>
        <span class="c1"># returns.</span>
        <span class="c1"># Note that we don&#39;t break if there was no reduction at all because</span>
        <span class="c1"># in that case we want to toggle only_merge_ops_with_view which might</span>
        <span class="c1"># still yield some significant reduction.</span>
        <span class="n">cum_duration</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">duration</span>
        <span class="n">mean_reduction_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_initial_ops</span> <span class="o">-</span> <span class="n">after</span><span class="p">)</span> <span class="o">/</span> <span class="n">cum_duration</span>
        <span class="n">last_reduction_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">before</span> <span class="o">-</span> <span class="n">after</span><span class="p">)</span> <span class="o">/</span> <span class="n">t</span><span class="o">.</span><span class="n">duration</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">if</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">last_reduction_rate</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">mean_reduction_rate</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Operator reduction rate fell below </span><span class="si">{}</span><span class="s2"> mean reduction rate. &quot;</span>
                <span class="s2">&quot;Stopping optimizer.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">))</span>
            <span class="k">break</span>

    <span class="c1"># Update model signals</span>
    <span class="k">for</span> <span class="n">sigdict</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">sig</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sigdict</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">sigdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="ow">in</span> <span class="n">single_pass</span><span class="o">.</span><span class="n">sig_replacements</span><span class="p">:</span>
                <span class="n">sigdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_pass</span><span class="o">.</span><span class="n">sig_replacements</span><span class="p">[</span><span class="n">sigdict</span><span class="p">[</span><span class="n">name</span><span class="p">]]</span>

    <span class="c1"># Reinitialize the model&#39;s operator list</span>
    <span class="k">del</span> <span class="n">model</span><span class="o">.</span><span class="n">operators</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">dg</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">OpMergePass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dg</span> <span class="o">=</span> <span class="n">BidirectionalDAG</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_replacements</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span> <span class="o">=</span> <span class="n">WeakKeyDefaultDict</span><span class="p">(</span><span class="n">WeakSet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span> <span class="o">=</span> <span class="n">WeakKeyDefaultDict</span><span class="p">(</span><span class="n">WeakSet</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># These variables will be initialized and used on each pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span> <span class="o">=</span> <span class="n">OpInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_merge_ops_with_view</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a single optimization pass.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        only_merge_ops_with_view : bool</span>
<span class="sd">            Limits operator merges to operators with views.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># --- Initialize pass state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="n">transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span> <span class="o">=</span> <span class="n">only_merge_ops_with_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># --- Do an optimization pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">perform_merges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Go through all operators and merge them where possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        only_merge_ops_with_view : bool</span>
<span class="sd">            Limit merges to operators with views.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We go through the ops grouped by type as only ops with the same</span>
        <span class="c1"># type can be merged.</span>
        <span class="n">by_type</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

        <span class="c1"># Note that we will stop once we merge any operator, so merges are</span>
        <span class="c1"># performed on at most one type of operator per pass.</span>
        <span class="c1"># The dependency graph and other information will be updated</span>
        <span class="c1"># before merging other operator types.</span>

        <span class="c1"># We go through ops in a heuristic order to reduce runtime</span>
        <span class="n">firstops</span> <span class="o">=</span> <span class="p">[</span><span class="n">ElementwiseInc</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">DotInc</span><span class="p">,</span> <span class="n">SimNeurons</span><span class="p">]</span>
        <span class="n">sortedops</span> <span class="o">=</span> <span class="n">firstops</span> <span class="o">+</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">by_type</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">firstops</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">optype</span> <span class="ow">in</span> <span class="n">sortedops</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">OpMerger</span><span class="o">.</span><span class="n">is_type_mergeable</span><span class="p">(</span><span class="n">optype</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges_for_subset</span><span class="p">(</span><span class="n">by_type</span><span class="p">[</span><span class="n">optype</span><span class="p">])</span>

            <span class="c1"># If we&#39;re not only merging views, the memory layout changes</span>
            <span class="c1"># and non-views are turned into views. In that case we need</span>
            <span class="c1"># to update the signals the operators are referring to before</span>
            <span class="c1"># trying to merge a different type of operators. Thus, we break</span>
            <span class="c1"># the loop here.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">perform_merges_for_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs operator merges for a subset of operators.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : list</span>
<span class="sd">            Subset of operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">by_view</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="p">[</span><span class="n">op</span><span class="p">]</span><span class="o">.</span><span class="n">v_base</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">by_view</span><span class="p">:</span>
                <span class="c1"># If an op has no views, v_base will be None.</span>
                <span class="c1"># If we&#39;re only merging views, then we get rid of this subset.</span>
                <span class="k">del</span> <span class="n">by_view</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">view_subset</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="n">by_view</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">view_subset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges_for_view_subset</span><span class="p">(</span><span class="n">view_subset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">by_view</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">by_view</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">perform_merges_for_view_subset</span><span class="p">(</span><span class="n">by_view</span><span class="p">[</span><span class="kc">None</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">perform_merges_for_view_subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform merges for a subset of operators with the same view base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : list</span>
<span class="sd">            Subset of operators. These need to have the same view base (can be</span>
<span class="sd">            None if it is None for all) for their first signal in</span>
<span class="sd">            `all_signals`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Sort to have sequential memory.</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="p">[</span><span class="n">op</span><span class="p">]</span><span class="o">.</span><span class="n">v_offset</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">])</span>
        <span class="n">sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>
        <span class="n">sorted_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_indices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_subset</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">op1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">:</span>
                <span class="c1"># Cannot merge merged operator again until dependency graph</span>
                <span class="c1"># has been updated</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">op1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op1</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">tomerge</span> <span class="o">=</span> <span class="n">OpsToMerge</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">)</span>

            <span class="c1"># For a merge to be possible the view of the next operator has to</span>
            <span class="c1"># start where the view of op1 ends. Because we have sorted the</span>
            <span class="c1"># operators by the start of their views we can do a binary search</span>
            <span class="c1"># and potentially skip a number of operators at the beginning.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                <span class="n">offsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="p">[</span><span class="n">op1</span><span class="p">]</span><span class="o">.</span><span class="n">v_size</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">sorted_subset</span><span class="p">[</span><span class="n">start</span><span class="p">:]:</span>

                <span class="k">if</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">not_sequential</span><span class="p">(</span><span class="n">op2</span><span class="p">):</span>
                    <span class="c1"># If this check is true the view of op2 does not</span>
                    <span class="c1"># immediately follow the view of the operators being</span>
                    <span class="c1"># merged. Because we iterate over the operators sorted by</span>
                    <span class="c1"># view offset there will be a gap between the end of the</span>
                    <span class="c1"># operators being merged and all remaining operators to</span>
                    <span class="c1"># loop over. With such a gap a merge is never possible and</span>
                    <span class="c1"># we can cut the loop short.</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="n">op2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">OpMerger</span><span class="o">.</span><span class="n">is_mergeable</span><span class="p">(</span><span class="n">op2</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
                    <span class="n">tomerge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tomerge</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_merge_ops_with_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">op1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges the given operators.</span>

<span class="sd">        This method will also update ``op_replacements``, ``sig_replacements``,</span>
<span class="sd">        and the internal list of merged operators to prevent further merges</span>
<span class="sd">        on the same operators before all required operators and signals have</span>
<span class="sd">        been replaced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged_op</span><span class="p">,</span> <span class="n">merged_sig</span> <span class="o">=</span> <span class="n">OpMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">merged_op</span><span class="p">)</span>

        <span class="c1"># Update tracking what has been merged and might be mergeable later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">might_merge</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">merged_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">all_dependents</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
            <span class="c1"># Mark all operators referencing the same signals as merged</span>
            <span class="c1"># (even though they are not) to prevent them from getting</span>
            <span class="c1"># merged before their signals have been updated.</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

        <span class="c1"># Signal related updates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolve_views_on_replaced_signals</span><span class="p">(</span><span class="n">merged_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig_replacements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">merged_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replace_op_signals</span><span class="p">(</span><span class="n">merged_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_signal_indexing</span><span class="p">(</span><span class="n">merged_op</span><span class="p">,</span> <span class="n">merged_sig</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resolve_views_on_replaced_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replaced_signals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">replaced_signals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">view</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">sig</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">view</span> <span class="ow">is</span> <span class="n">sig</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">assert</span> <span class="n">view</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">sig</span>
                <span class="n">base_replacement</span> <span class="o">=</span> <span class="n">replaced_signals</span><span class="p">[</span><span class="n">sig</span><span class="p">]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">offset</span>
                <span class="n">strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">a</span> <span class="o">//</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span>
                        <span class="n">view</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
                        <span class="n">view</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
                        <span class="n">base_replacement</span><span class="o">.</span><span class="n">strides</span><span class="p">,</span>
                        <span class="n">fillvalue</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">offset</span>
                    <span class="n">base_replacement</span> <span class="o">=</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">base</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="n">base_replacement</span><span class="o">.</span><span class="n">initial_value</span>
                <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">buffer</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
                                           <span class="n">dtype</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                           <span class="n">shape</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                           <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                           <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span>
                <span class="n">replaced_signals</span><span class="p">[</span><span class="n">view</span><span class="p">]</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span>
                                                <span class="n">name</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                <span class="n">base</span><span class="o">=</span><span class="n">base_replacement</span><span class="p">,</span>
                                                <span class="n">readonly</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="n">readonly</span><span class="p">,</span>
                                                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace_op_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replaced_signals</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">replaced_signals</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="c1"># Update the op&#39;s signals</span>
            <span class="n">v</span><span class="o">.</span><span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">sets</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">incs</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">incs</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">reads</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">reads</span><span class="p">]</span>
            <span class="n">v</span><span class="o">.</span><span class="n">updates</span> <span class="o">=</span> <span class="p">[</span><span class="n">replaced_signals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">updates</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_signal_indexing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merged_op</span><span class="p">,</span> <span class="n">replaced_signals</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">merged_op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">merged_op</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">from_sig</span><span class="p">,</span> <span class="n">to_sig</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">replaced_signals</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">to_sig</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig2ops</span><span class="p">[</span><span class="n">from_sig</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">to_sig</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">base2views</span><span class="p">[</span><span class="n">to_sig</span><span class="o">.</span><span class="n">base</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">to_sig</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OpInfo</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analyze and store extra information about operators.&quot;&quot;&quot;</span>

    <span class="n">_OpDetails</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
        <span class="s2">&quot;_OpDetails&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;first_view&quot;</span><span class="p">,</span> <span class="s2">&quot;v_offset&quot;</span><span class="p">,</span> <span class="s2">&quot;v_size&quot;</span><span class="p">,</span> <span class="s2">&quot;v_base&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpInfo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">first_view</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">all_signals</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OpDetails</span><span class="p">(</span><span class="n">first_view</span><span class="o">=</span><span class="n">first_view</span><span class="p">,</span>
                                                <span class="n">v_offset</span><span class="o">=</span><span class="n">first_view</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                                                <span class="n">v_size</span><span class="o">=</span><span class="n">first_view</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
                                                <span class="n">v_base</span><span class="o">=</span><span class="n">first_view</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OpDetails</span><span class="p">(</span>
                    <span class="n">first_view</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">v_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v_base</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">OpsToMerge</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analyze and store extra information about a list of ops to be merged.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_op</span><span class="p">,</span> <span class="n">merged</span><span class="p">,</span> <span class="n">merged_dependents</span><span class="p">,</span> <span class="n">dependents</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged</span> <span class="o">=</span> <span class="n">merged</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="o">=</span> <span class="n">merged_dependents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dependents</span> <span class="o">=</span> <span class="n">dependents</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_op</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span> <span class="o">=</span> <span class="n">OpInfo</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">all_signals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initial_op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_dependents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">initial_op</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_signals</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_dependents</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">all_signals</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">all_signals</span><span class="p">):</span>
            <span class="c1"># If one op&#39;s signal is a view, the other must be as well</span>
            <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">is_view</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s2</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">is_view</span><span class="p">:</span>
                <span class="c1"># Views must be on the same base</span>
                <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s2</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># Views must have the same dtype</span>
                <span class="k">elif</span> <span class="n">s1</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s2</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># Views must have the same strides</span>
                <span class="k">elif</span> <span class="n">s1</span><span class="o">.</span><span class="n">strides</span> <span class="o">!=</span> <span class="n">s2</span><span class="o">.</span><span class="n">strides</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">not_sequential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">lastop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lastop</span><span class="o">.</span><span class="n">v_offset</span> <span class="o">+</span> <span class="n">lastop</span><span class="o">.</span><span class="n">v_size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">opinfo</span><span class="p">[</span><span class="n">op</span><span class="p">]</span><span class="o">.</span><span class="n">v_offset</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OpMerger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">mergers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="n">merger</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">[</span><span class="n">tomerge</span><span class="o">.</span><span class="n">optype</span><span class="p">]</span>

        <span class="n">independent_of_ops_tomerge</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">all_dependents</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">independent_of_prior_merges</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">merged</span> <span class="ow">and</span>
            <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">merged_dependents</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">merged</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">dependents</span><span class="p">[</span><span class="n">op</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="ow">is</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">optype</span> <span class="ow">and</span>
            <span class="n">independent_of_ops_tomerge</span> <span class="ow">and</span>
            <span class="n">independent_of_prior_merges</span> <span class="ow">and</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">is_type_mergeable</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">optype</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">tomerge</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">op</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">merger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">merger</span><span class="o">.</span><span class="n">is_mergeable</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">last_op</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_type_mergeable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">optype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">optype</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">optype</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">merger</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">optype</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Merger for operator type </span><span class="si">{}</span><span class="s2"> overwritten.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">optype</span><span class="p">))</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">mergers</span><span class="p">[</span><span class="n">optype</span><span class="p">]</span> <span class="o">=</span> <span class="n">merger</span>
            <span class="k">return</span> <span class="n">merger</span>
        <span class="k">return</span> <span class="n">register</span>


<span class="k">class</span> <span class="nc">Merger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">all_signals</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">all_signals</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot merge arbitrary ops.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_dicts</span><span class="p">(</span><span class="o">*</span><span class="n">dicts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges the given dictionaries into a single dictionary.</span>

<span class="sd">        This function assumes and enforces that no keys overlap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">other_d</span> <span class="ow">in</span> <span class="n">dicts</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other_d</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other_d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>


<span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">TimeUpdate</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TimeUpdateMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="n">step</span><span class="p">,</span> <span class="n">step_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">step</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">time_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">TimeUpdate</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">time</span><span class="p">),</span>
                <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">step_sigr</span><span class="p">,</span> <span class="n">time_sigr</span><span class="p">))</span>


<span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">Reset</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ResetMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">dst</span><span class="p">])</span> <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="n">dst</span><span class="p">,</span> <span class="n">replacements</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">dst</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">replacements</span>


<span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">Copy</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">CopyMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">src</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">dst</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">op1</span><span class="o">.</span><span class="n">src_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">dst_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">op2</span><span class="o">.</span><span class="n">src_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">dst_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">op1</span><span class="o">.</span><span class="n">inc</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">inc</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_slice</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mixed Ellipsis with list of indices.&quot;</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">merged_slice</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sig</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
            <span class="n">merged_slice</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sl</span><span class="p">])</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">sig</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">merged_slice</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="n">src_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">src</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
        <span class="n">dst_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">dst</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>

        <span class="n">src</span><span class="p">,</span> <span class="n">src_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">src_sigs</span><span class="p">)</span>
        <span class="n">dst</span><span class="p">,</span> <span class="n">dst_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dst_sigs</span><span class="p">)</span>
        <span class="n">src_slice</span> <span class="o">=</span> <span class="n">CopyMerger</span><span class="o">.</span><span class="n">merge_slice</span><span class="p">(</span>
            <span class="n">src_sigs</span><span class="p">,</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">src_slice</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">dst_slice</span> <span class="o">=</span> <span class="n">CopyMerger</span><span class="o">.</span><span class="n">merge_slice</span><span class="p">(</span>
            <span class="n">dst_sigs</span><span class="p">,</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">dst_slice</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span>
            <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src_slice</span><span class="o">=</span><span class="n">src_slice</span><span class="p">,</span> <span class="n">dst_slice</span><span class="o">=</span><span class="n">dst_slice</span><span class="p">,</span>
            <span class="n">inc</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">inc</span><span class="p">),</span> <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">src_sigr</span><span class="p">,</span> <span class="n">dst_sigr</span><span class="p">)</span>


<span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ElementwiseInc</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ElementwiseIncMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="n">scalar_mult</span> <span class="o">=</span> <span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">non_scalar_mult</span> <span class="o">=</span> <span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="ow">and</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">X</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">op1</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">Y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span>
            <span class="p">((</span><span class="n">scalar_mult</span> <span class="ow">and</span> <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span><span class="p">)</span> <span class="ow">or</span>
             <span class="p">(</span><span class="n">non_scalar_mult</span> <span class="ow">and</span>
                 <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">==</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">)</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">A_sigr</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">A_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">A</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">X_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">Y_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">Y</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ElementwiseInc</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span>
                <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">A_sigr</span><span class="p">,</span> <span class="n">X_sigr</span><span class="p">,</span> <span class="n">Y_sigr</span><span class="p">))</span>


<span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">DotInc</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DotIncMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">):</span>
        <span class="n">none_shared</span> <span class="o">=</span> <span class="n">Merger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">tomerge</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="n">all_x_shared</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">op</span><span class="o">.</span><span class="n">A</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">all_signals</span> <span class="ow">and</span>
            <span class="n">op</span><span class="o">.</span><span class="n">Y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">all_signals</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">X</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">Y</span><span class="p">]</span> <span class="ow">and</span> <span class="n">op</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">tomerge</span><span class="o">.</span><span class="n">ops</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">none_shared</span> <span class="ow">or</span> <span class="n">all_x_shared</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">op1</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="n">op2</span><span class="o">.</span><span class="n">X</span><span class="p">:</span>
            <span class="c1"># simple merge might be possible</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">Y</span><span class="p">])</span>
                    <span class="ow">and</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="p">]))</span>

        <span class="c1"># check if BSR merge is possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Not using check() for A, because A must not be a view.</span>
            <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="p">])</span>
            <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">bsr_matrix</span>
            <span class="k">assert</span> <span class="n">bsr_matrix</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Skipping some optimization steps because SciPy is &quot;</span>
                          <span class="s2">&quot;not installed. Installing SciPy may result in &quot;</span>
                          <span class="s2">&quot;faster simulations.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">X</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">([</span><span class="n">op1</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">Y</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">op1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="c1"># Simple merge if all X are the same.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">A_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
            <span class="n">Y</span><span class="p">,</span> <span class="n">Y_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">Y</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">DotInc</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">),</span>
                    <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">A_sigr</span><span class="p">,</span> <span class="n">Y_sigr</span><span class="p">))</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">o2</span><span class="o">.</span><span class="n">X</span>
                   <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="k">for</span> <span class="n">o2</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># BSR merge if X differ</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">X_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">X</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">Y</span><span class="p">,</span> <span class="n">Y_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">Y</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>

        <span class="c1"># Construct sparse A representation</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;bsr_merged&lt;</span><span class="si">{first}</span><span class="s1">, ..., </span><span class="si">{last}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">first</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">readonly</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">readonly</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="n">readonly</span><span class="p">)</span>
        <span class="n">A_sigr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">A</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]):</span>
            <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%i</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">base</span><span class="o">=</span><span class="n">A</span><span class="p">,</span>
                               <span class="n">offset</span><span class="o">=</span><span class="n">i</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">==</span> <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">initial_value</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">A_sigr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">reshape</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">reshape_dot</span><span class="p">(</span>
            <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span>
            <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">BsrDotInc</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="o">=</span><span class="n">indptr</span><span class="p">,</span> <span class="n">reshape</span><span class="o">=</span><span class="n">reshape</span><span class="p">),</span>
            <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">X_sigr</span><span class="p">,</span> <span class="n">Y_sigr</span><span class="p">,</span> <span class="n">A_sigr</span><span class="p">))</span>


<span class="nd">@OpMerger</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">SimNeurons</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SimNeuronsMerger</span><span class="p">(</span><span class="n">Merger</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_mergeable</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">neurons</span> <span class="o">==</span> <span class="n">op2</span><span class="o">.</span><span class="n">neurons</span> <span class="ow">and</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">SigMerger</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">op1</span><span class="o">.</span><span class="n">all_signals</span><span class="p">,</span> <span class="n">op2</span><span class="o">.</span><span class="n">all_signals</span><span class="p">)))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">gather</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>

        <span class="n">J</span><span class="p">,</span> <span class="n">J_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">gather</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">))</span>
        <span class="n">output</span><span class="p">,</span> <span class="n">out_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">gather</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">))</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">states_sigr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">signals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">gather</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="s1">&#39;states&#39;</span><span class="p">)):</span>
            <span class="n">st</span><span class="p">,</span> <span class="n">st_sigr</span> <span class="o">=</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">signals</span><span class="p">)</span>
            <span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
            <span class="n">states_sigr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">st_sigr</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SimNeurons</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">states</span><span class="p">),</span>
                <span class="n">Merger</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">(</span><span class="n">J_sigr</span><span class="p">,</span> <span class="n">out_sigr</span><span class="p">,</span> <span class="n">states_sigr</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">SigMerger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all signals can be concatenated along a given axis.</span>

<span class="sd">        For views, this includes also a check that the signals have a common</span>
<span class="sd">        base and agree on the strides.</span>

<span class="sd">        In comparison to the ``check_*`` functions, this function  does</span>
<span class="sd">        not throw exceptions and allows for either signals or signal views.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">signals</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signals</span><span class="p">):</span>
            <span class="c1"># Signal appears twice in list.</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mix of signals and not signals</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we haven&#39;t failed yet, then the signals are compatible</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all signals can be merged along a given axis.</span>

<span class="sd">        If this is not possible, or any signals are views, a</span>
<span class="sd">        ``ValueError`` will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge views.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have the same number of dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">initial_value</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;0-d signals must have the same initial value.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have same shape except on concatenation &quot;</span>
                    <span class="s2">&quot;axis.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have the same dtype.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that all signal views can be merged along a given axis.</span>

<span class="sd">        If this is not possible, or any signals are not views,</span>
<span class="sd">        a ``ValueError`` will be raised.</span>

<span class="sd">        ``signals`` must be ordered by the offset into the base signal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge non-views.&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must share the same base.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must have same dtype.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have the same number of dimensions.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">strides</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Signals must have equal strides.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Signals must have same shape except on concatenation &quot;</span>
                    <span class="s2">&quot;axis.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Views are not sequential.&quot;</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges multiple signals or signal views into one contiguous signal.</span>

<span class="sd">        Note that if any of the signals are linked to another signal (by being</span>
<span class="sd">        the base of a view), the merged signal will not reflect those links</span>
<span class="sd">        anymore.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signals : sequence</span>
<span class="sd">            Signals to merge. Must not contain views.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to concatenate the signals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_signal : Signal</span>
<span class="sd">            The merged signal.</span>
<span class="sd">        replacements : dict</span>
<span class="sd">            Dictionary mapping from the old signals to new  signals that are</span>
<span class="sd">            a view into the merged signal. Used to replace old signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">are_views</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">is_view</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_views</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_views</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SigMerger</span><span class="o">.</span><span class="n">merge_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merged mixed views and non-views.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges multiple signal into one contiguous signal.</span>

<span class="sd">        Note that if any of the signals are linked to another signal (by being</span>
<span class="sd">        the base of a view), the merged signal will not reflect</span>
<span class="sd">        those links anymore.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signals : sequence</span>
<span class="sd">            Signals to merge. Must not contain views.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to concatenate the signals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_signal : Signal</span>
<span class="sd">            The merged signal.</span>
<span class="sd">        replacements : dict</span>
<span class="sd">            Dictionary mapping from the old signals to new  signals that are</span>
<span class="sd">            a view into the merged signal. Used to replace old signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_signals</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">initial_value</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_value</span> <span class="o">=</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">initial_value</span>
        <span class="n">readonly</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">readonly</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;merged&lt;&#39;</span> <span class="o">+</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;, ..., &#39;</span> <span class="o">+</span> <span class="n">signals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>
        <span class="n">merged_signal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="n">readonly</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                <span class="n">indexing</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">initial_value</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">indexing</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">replacements</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_signal</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexing</span><span class="p">)]</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">replacements</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">merged_signal</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">merged_signal</span><span class="p">,</span> <span class="n">replacements</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">merge_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges multiple signal views into one continguous signal view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signals : sequence</span>
<span class="sd">            Signals to merge. Must only contain views.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to concatenate the signals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_signal : Signal</span>
<span class="sd">            The merged signal.</span>
<span class="sd">        replacements : dict</span>
<span class="sd">            Dictionary mapping from the old signals to new  signals that are</span>
<span class="sd">            a view into the merged signal. Used to replace old signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SigMerger</span><span class="o">.</span><span class="n">check_views</span><span class="p">(</span><span class="n">signals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># abs_offset = min(s.abs_offset for s in signals)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">offset</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">),)</span> <span class="o">+</span>
            <span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">initial_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">initial_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
        <span class="n">merged_signal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span>
            <span class="n">initial_value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="p">,</span>
            <span class="n">readonly</span><span class="o">=</span><span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">readonly</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">signals</span><span class="p">),</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_signal</span><span class="p">,</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Groups the given list by the value returned by ``keyfunc``.</span>

<span class="sd">    Similar to ``itertools.groupby``, but returns a dict, and does not depend</span>
<span class="sd">    on the order of the input list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">keyfunc</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>
</pre></div>

          </div>
            
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Nengo core 2.8.0 docs</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2013-2017, Applied Brain Research. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Nengo frontend API &#8212; Nengo 3.1.0 docs</title>
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
<link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,400i,600|Rajdhani:700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css" integrity="sha384-oS3vJWv+0UjzBfQzYUhtDYW+Pj2yciDJxpsK1OYPAYjqT085Qq/1cq5FLXAZQ7Ay" crossorigin="anonymous">
<link rel="stylesheet" href="https://www.nengo.ai/css/bootstrap.css" type="text/css">
<style>
  body .title-bar,
  body .documentation-source h1:after {
    background-color: #a8acaf;
  }
</style>
<!-- Google Tag Manager -->
<script>
 (function (w, d, s, l, i) {
   w[l] = w[l] || [];
   w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
   var f = d.getElementsByTagName(s)[0],
       j = d.createElement(s),
       dl = l != "dataLayer" ? "&l=" + l : "";
   j.async = true;
   j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
   f.parentNode.insertBefore(j, f);
 })(window, document, "script", "dataLayer", "GTM-KWCR2HN");
</script>
<!-- End Google Tag Manager -->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://unpkg.com/scrollreveal"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stickyfill/2.1.0/stickyfill.min.js"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
<!-- From basic/layout.html -->
<script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
  
  
<script src="_static/underscore.js"></script>
  
  
<script src="_static/doctools.js"></script>
  
  
<script src="_static/language_data.js"></script>
  
  
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
  
  
<script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  
<script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Nengo backend API" href="backend-api.html" />
    <link rel="prev" title="User guide" href="user-guide.html" />
<link rel="stylesheet" type="text/css" href="_static/custom.css">


<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  </head><body class="bg-dark">

<header class="fixed-top header-top shadow-sm">
  <nav class="navbar navbar-expand-md navbar-light bg-white">
    <a class="navbar-brand" href="https://www.nengo.ai/">
      <img
        src="https://www.nengo.ai/design/_images/general-full-light.svg"
        alt="Nengo"
        class="logo"
      />
    </a>
    <button
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbar-collapse"
      aria-controls="navbar-collapse"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar-collapse">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/">What is Nengo?</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://www.nengo.ai/examples/">Examples</a>
        </li>
        <li class="nav-item dropdown active">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-docs"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Documentation</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-docs"
          >
            
            <a class="dropdown-item" href="https://www.nengo.ai/nengo/">Nengo core</a>
            <a class="dropdown-item" href="https://github.com/nengo/nengo-gui/">NengoGUI</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-dl/">NengoDL</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-spa/">NengoSPA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-extras/">NengoExtras</a>
            <a class="dropdown-item" href="https://arvoelke.github.io/nengolib-docs/">Nengolib</a>
            <a class="dropdown-item" href="https://www.nengo.ai/keras-spiking">KerasSpiking</a>
            <a class="dropdown-item" href="https://www.nengo.ai/pytorch-spiking">PyTorchSpiking</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-fpga/">NengoFPGA</a>
            <a class="dropdown-item" href="https://www.nengo.ai/nengo-loihi/">NengoLoihi</a>
            <a class="dropdown-item" href="https://labs.nengo.ai/nengo-ocl/">NengoOCL</a>
            <a class="dropdown-item" href="https://github.com/project-rig/nengo_spinnaker">NengoSpiNNaker</a>
            <a class="dropdown-item" href="https://github.com/nengo-labs/nengo-mpi">NengoMPI</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/documentation/"
              >All documentation</a
            >
          </div>
        </li>
        <li class="nav-item dropdown">
          <a
            class="nav-link dropdown-toggle"
            id="navbar-dropdown-community"
            data-toggle="dropdown"
            aria-haspopup="true"
            aria-expanded="false"
            href="#"
            >Community</a
          >
          <div
            class="dropdown-menu shadow-lg border-0"
            aria-labelledby="navbar-dropdown-community"
          >
            <a class="dropdown-item" href="https://forum.nengo.ai">Forum</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="https://www.nengo.ai/people/"
              >People</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/summer-school/"
              >Summer school</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/contributing/"
              >Contributing</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/publications/"
              >Publications</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/videos/"
              >Videos</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/conduct/"
              >Code of conduct</a
            >
            <a class="dropdown-item" href="https://www.nengo.ai/caa/">CAA</a>
          </div>
        </li>
        <li class="nav-item">
          <a
            class="nav-link btn btn-success btn-sm text-white"
            href="https://www.nengo.ai/getting-started/"
            >Getting started</a
          >
        </li>
      </ul>
    </div>
  </nav>
</header>
<div class="main-content gradient-top">
  <div class="container-fluid">
    <div class="row"><a class="toggle-sidenav d-block d-md-none" href="#"
  ><i class="icon-close fa fa-fw fa-arrow-left"></i
  ><i class="icon-open fa fa-fw fa-arrow-right"></i
></a>
<div role="complementary" class="sidenav col-4 col-xl-3 p-0 border-right">
  <h3 class="pt-5 px-5">
    <a href="index.html">
      <img
        class="img-fluid documentation-image"
        src="https://www.nengo.ai/design/_images/general-full-light.svg"
        alt="Nengo"
      />
    </a>
  </h3>
<form class="px-5 py-3 my-0 border-bottom" action="search.html" method="get">
  <div class="form-group form-group-single">
    <input type="text" name="q" class="form-control" placeholder="Search" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
    <button type="submit" class="btn btn-link">
      <img src="https://www.nengo.ai/img/icon-search.svg" alt="Go" />
    </button>
  </div>
</form><div class="p-5 toctree">
  
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="user-guide.html">User guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Nengo frontend API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nengo-objects">Nengo Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.dists">Distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.learning_rules">Learning rule types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.neurons">Neuron types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.processes">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.solvers">Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.synapses">Synapse models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nengo.transforms">Transforms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="backend-api.html">Nengo backend API</a></li>
<li class="toctree-l2"><a class="reference internal" href="config.html">Setting parameters with Configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="networks.html">Reusable networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="spa.html">Semantic Pointer Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html">Advanced topics</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to Nengo</a></li>
<li class="toctree-l1"><a class="reference internal" href="project.html">Project information</a></li>
</ul>

  
  </div>
  
  <form class="p-5 my-0 border-top">
    <div class="form-group">
      <label class="text-gray">Version:</label>
      <select class="custom-select" onchange="switchVersion(this);">
        
        
        <option value="../frontend-api.html">latest</option>
        
        
          
        <option selected>v3.1.0</option>
          
        
          
        <option value="../v3.0.0/frontend-api.html">
          v3.0.0
        </option>
          
        
          
        <option value="../v2.8.0/frontend-api.html">
          v2.8.0
        </option>
          
        
      </select>
    </div>
  </form>
  
</div>
      

      <div class="col-12 col-md-8 col-xl-9">
        <div class="container">
          <div class="row">
            <div class="col-10 offset-1 pb-5 documentation-source" role="main">
              
              
  <div class="section" id="nengo-frontend-api">
<h1>Nengo frontend API<a class="headerlink" href="#nengo-frontend-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="nengo-objects">
<h2>Nengo Objects<a class="headerlink" href="#nengo-objects" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Network</span></code></a></p></td>
<td><p>A network contains ensembles, nodes, connections, and other networks.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Ensemble</span></code></a></p></td>
<td><p>A group of neurons that collectively represent a vector.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.ensemble.Neurons" title="nengo.ensemble.Neurons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.ensemble.Neurons</span></code></a></p></td>
<td><p>An interface for making connections directly to an ensemble’s neurons.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Node</span></code></a></p></td>
<td><p>Provide non-neural inputs to Nengo objects and process outputs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Connection</span></code></a></p></td>
<td><p>Connects two objects together.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.connection.LearningRule" title="nengo.connection.LearningRule"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.connection.LearningRule</span></code></a></p></td>
<td><p>An interface for making connections to a learning rule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Probe</span></code></a></p></td>
<td><p>A probe is an object that collects data from the simulation.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.Network">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Network</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">label</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">add_to_container</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/network.py#L19-L311"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>A network contains ensembles, nodes, connections, and other networks.</p>
<p>A network is primarily used for grouping together related
objects and connections for visualization purposes.
However, you can also use networks as a nice way to reuse
network creation code.</p>
<p>To group together related objects that you do not need to reuse,
you can create a new <code class="docutils literal notranslate"><span class="pre">Network</span></code> and add objects in a <code class="docutils literal notranslate"><span class="pre">with</span></code> block.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Vision&quot;</span><span class="p">):</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">n_neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Motor&quot;</span><span class="p">):</span>
        <span class="n">sma</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">n_neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">sma</span><span class="p">)</span>
</pre></div>
</div>
<p>To reuse a group of related objects, you can create a new subclass
of <code class="docutils literal notranslate"><span class="pre">Network</span></code>, and add objects in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method.
For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">OcularDominance</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="n">n_neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span>
<span class="k">with</span> <span class="n">network</span><span class="p">:</span>
    <span class="n">left_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">right_eye</span> <span class="o">=</span> <span class="n">OcularDominance</span><span class="p">()</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">left_eye</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="n">right_eye</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the network.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed that will be fed to the random number generator.
Setting the seed makes the network’s build process deterministic.</p>
</dd>
<dt><strong>add_to_container</strong><span class="classifier">bool, optional</span></dt><dd><p>Determines if this network will be added to the current container.
If None, this network will be added to the network at the top of the
<code class="docutils literal notranslate"><span class="pre">Network.context</span></code> stack unless the stack is empty.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>connections</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connection</span></code></a> instances in this network.</p>
</dd>
<dt><strong>ensembles</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Ensemble" title="nengo.Ensemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ensemble</span></code></a> instances in this network.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>Name of this network.</p>
</dd>
<dt><strong>networks</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Network</span></code></a> instances in this network.</p>
</dd>
<dt><strong>nodes</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Node" title="nengo.Node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Node</span></code></a> instances in this network.</p>
</dd>
<dt><strong>probes</strong><span class="classifier">list</span></dt><dd><p><a class="reference internal" href="#nengo.Probe" title="nengo.Probe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Probe</span></code></a> instances in this network.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>Random seed used by this network.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Network.add">
<em class="property">static </em><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/network.py#L112-L132"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the passed object to <code class="docutils literal notranslate"><span class="pre">Network.context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.default_config">
<em class="property">static </em><code class="sig-name descname">default_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/network.py#L134-L137"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Network.default_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a <a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Config</span></code></a> object for setting defaults.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.all_objects">
<em class="property">property </em><code class="sig-name descname">all_objects</code><a class="headerlink" href="#nengo.Network.all_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All objects in this network and its subnetworks.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.all_ensembles">
<em class="property">property </em><code class="sig-name descname">all_ensembles</code><a class="headerlink" href="#nengo.Network.all_ensembles" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All ensembles in this network and its subnetworks.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.all_nodes">
<em class="property">property </em><code class="sig-name descname">all_nodes</code><a class="headerlink" href="#nengo.Network.all_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All nodes in this network and its subnetworks.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.all_networks">
<em class="property">property </em><code class="sig-name descname">all_networks</code><a class="headerlink" href="#nengo.Network.all_networks" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All networks in this network and its subnetworks.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.all_connections">
<em class="property">property </em><code class="sig-name descname">all_connections</code><a class="headerlink" href="#nengo.Network.all_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All connections in this network and its subnetworks.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.all_probes">
<em class="property">property </em><code class="sig-name descname">all_probes</code><a class="headerlink" href="#nengo.Network.all_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>(list) All probes in this network and its subnetworks.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.config">
<em class="property">property </em><code class="sig-name descname">config</code><a class="headerlink" href="#nengo.Network.config" title="Permalink to this definition">¶</a></dt>
<dd><p>(<a class="reference internal" href="config.html#nengo.Config" title="nengo.Config"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Config</span></code></a>) Configuration for this network.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Network.n_neurons">
<em class="property">property </em><code class="sig-name descname">n_neurons</code><a class="headerlink" href="#nengo.Network.n_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Number of neurons in this network, including subnetworks.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Ensemble">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Ensemble</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_neurons</span></em>, <em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">radius</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">encoders</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">intercepts</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">max_rates</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">eval_points</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">n_eval_points</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">neuron_type</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">gain</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">noise</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">normalize_encoders</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">label</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">Default</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/ensemble.py#L8-L198"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>A group of neurons that collectively represent a vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_neurons</strong><span class="classifier">int</span></dt><dd><p>The number of neurons.</p>
</dd>
<dt><strong>dimensions</strong><span class="classifier">int</span></dt><dd><p>The number of representational dimensions.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>The representational radius of the ensemble.</p>
</dd>
<dt><strong>encoders</strong><span class="classifier">Distribution or (n_neurons, dimensions) array_like, optional</span></dt><dd><p>The encoders used to transform from representational space
to neuron space. Each row is a neuron’s encoder; each column is a
representational dimension.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">Distribution or (n_neurons,) array_like, optional</span></dt><dd><p>The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal notranslate"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal notranslate"><span class="pre">c</span></code> is the given intercept.</p>
</dd>
<dt><strong>max_rates</strong><span class="classifier">Distribution or (n_neurons,) array_like, optional</span></dt><dd><p>The activity of each neuron when the input signal <code class="docutils literal notranslate"><span class="pre">x</span></code> is magnitude 1
and aligned with that neuron’s encoder <code class="docutils literal notranslate"><span class="pre">e</span></code>;
i.e., when <code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>eval_points</strong><span class="classifier">Distribution or (n_eval_points, dims) array_like, optional</span></dt><dd><p>The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</dd>
<dt><strong>n_eval_points</strong><span class="classifier">int, optional</span></dt><dd><p>The number of evaluation points to be drawn from the <code class="docutils literal notranslate"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</dd>
<dt><strong>neuron_type</strong><span class="classifier"><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeuronType</span></code></a>, optional</span></dt><dd><p>The model that simulates all neurons in the ensemble
(see <a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NeuronType</span></code></a>).</p>
</dd>
<dt><strong>gain</strong><span class="classifier">Distribution or (n_neurons,) array_like</span></dt><dd><p>The gains associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal notranslate"><span class="pre">max_rates</span></code> and <code class="docutils literal notranslate"><span class="pre">intercepts</span></code>.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">Distribution or (n_neurons,) array_like</span></dt><dd><p>The biases associated with each neuron in the ensemble. If None, then
the gain will be solved for using <code class="docutils literal notranslate"><span class="pre">max_rates</span></code> and <code class="docutils literal notranslate"><span class="pre">intercepts</span></code>.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">Process, optional</span></dt><dd><p>Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</dd>
<dt><strong>normalize_encoders</strong><span class="classifier">bool, optional</span></dt><dd><p>Indicates whether the encoders should be normalized.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A name for the ensemble. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bias</strong><span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt><dd><p>The biases associated with each neuron in the ensemble.</p>
</dd>
<dt><strong>dimensions</strong><span class="classifier">int</span></dt><dd><p>The number of representational dimensions.</p>
</dd>
<dt><strong>encoders</strong><span class="classifier">Distribution or (n_neurons, dimensions) array_like</span></dt><dd><p>The encoders, used to transform from representational space
to neuron space. Each row is a neuron’s encoder, each column is a
representational dimension.</p>
</dd>
<dt><strong>eval_points</strong><span class="classifier">Distribution or (n_eval_points, dims) array_like</span></dt><dd><p>The evaluation points used for decoder solving, spanning the interval
(-radius, radius) in each dimension, or a distribution from which
to choose evaluation points.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt><dd><p>The gains associated with each neuron in the ensemble.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">Distribution or (n_neurons) array_like or None</span></dt><dd><p>The point along each neuron’s encoder where its activity is zero. If
<code class="docutils literal notranslate"><span class="pre">e</span></code> is the neuron’s encoder, then the activity will be zero when
<code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">&lt;=</span> <span class="pre">c</span></code>, where <code class="docutils literal notranslate"><span class="pre">c</span></code> is the given intercept.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str or None</span></dt><dd><p>A name for the ensemble. Used for debugging and visualization.</p>
</dd>
<dt><strong>max_rates</strong><span class="classifier">Distribution or (n_neurons,) array_like or None</span></dt><dd><p>The activity of each neuron when <code class="docutils literal notranslate"><span class="pre">dot(x,</span> <span class="pre">e)</span> <span class="pre">=</span> <span class="pre">1</span></code>,
where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the neuron’s encoder.</p>
</dd>
<dt><strong>n_eval_points</strong><span class="classifier">int or None</span></dt><dd><p>The number of evaluation points to be drawn from the <code class="docutils literal notranslate"><span class="pre">eval_points</span></code>
distribution. If None, then a heuristic is used to determine
the number of evaluation points.</p>
</dd>
<dt><strong>n_neurons</strong><span class="classifier">int or None</span></dt><dd><p>The number of neurons.</p>
</dd>
<dt><strong>neuron_type</strong><span class="classifier">NeuronType</span></dt><dd><p>The model that simulates all neurons in the ensemble
(see <code class="docutils literal notranslate"><span class="pre">nengo.neurons</span></code>).</p>
</dd>
<dt><strong>noise</strong><span class="classifier">Process or None</span></dt><dd><p>Random noise injected directly into each neuron in the ensemble
as current. A sample is drawn for each individual neuron on
every simulation step.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The representational radius of the ensemble.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int or None</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Ensemble.neurons">
<em class="property">property </em><code class="sig-name descname">neurons</code><a class="headerlink" href="#nengo.Ensemble.neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>A direct interface to the neurons in the ensemble.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Ensemble.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.Ensemble.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Ensemble.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.Ensemble.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the ensemble.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.ensemble.Neurons">
<em class="property">class </em><code class="sig-prename descclassname">nengo.ensemble.</code><code class="sig-name descname">Neurons</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ensemble</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/ensemble.py#L201-L265"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.ensemble.Neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections directly to an ensemble’s neurons.</p>
<p>This should only ever be accessed through the <code class="docutils literal notranslate"><span class="pre">neurons</span></code> attribute of an
ensemble, as a way to signal to <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connection</span></code></a> that the connection
should be made directly to the neurons rather than to the ensemble’s
decoded value, e.g.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="nengo.ensemble.Neurons.ensemble">
<em class="property">property </em><code class="sig-name descname">ensemble</code><a class="headerlink" href="#nengo.ensemble.Neurons.ensemble" title="Permalink to this definition">¶</a></dt>
<dd><p>(Ensemble) The ensemble these neurons are part of.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.ensemble.Neurons.probeable">
<em class="property">property </em><code class="sig-name descname">probeable</code><a class="headerlink" href="#nengo.ensemble.Neurons.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the neuron population.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.ensemble.Neurons.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.ensemble.Neurons.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.ensemble.Neurons.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of neurons in the population.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Node">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Node</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">output</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">size_in</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">size_out</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">label</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">Default</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/node.py#L139-L209"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide non-neural inputs to Nengo objects and process outputs.</p>
<p>Nodes can accept input, and perform arbitrary computations
for the purpose of controlling a Nengo simulation.
Nodes are typically not part of a brain model per se,
but serve to summarize the assumptions being made
about sensory data or other environment variables
that cannot be generated by a brain model alone.</p>
<p>Nodes can also be used to test models by providing specific input signals
to parts of the model, and can simplify the input/output interface of a
<a class="reference internal" href="#nengo.Network" title="nengo.Network"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Network</span></code></a> when used as a relay to/from its internal
ensembles (see <a class="reference internal" href="networks.html#nengo.networks.EnsembleArray" title="nengo.networks.EnsembleArray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EnsembleArray</span></code></a> for an example).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output</strong><span class="classifier">callable, array_like, or None</span></dt><dd><p>Function that transforms the Node inputs into outputs,
a constant output value, or None to transmit signals unchanged.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int, optional</span></dt><dd><p>The number of dimensions of the input data parameter.</p>
</dd>
<dt><strong>size_out</strong><span class="classifier">int, optional</span></dt><dd><p>The size of the output signal. If None, it will be determined
based on the values of <code class="docutils literal notranslate"><span class="pre">output</span></code> and <code class="docutils literal notranslate"><span class="pre">size_in</span></code>.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A name for the node. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.
Note: no aspects of the node are random, so currently setting
this seed has no effect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>The name of the node.</p>
</dd>
<dt><strong>output</strong><span class="classifier">callable, array_like, or None</span></dt><dd><p>The given output.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int</span></dt><dd><p>The number of dimensions for incoming connection.</p>
</dd>
<dt><strong>size_out</strong><span class="classifier">int</span></dt><dd><p>The number of output dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.Connection">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Connection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pre</span></em>, <em class="sig-param"><span class="n">post</span></em>, <em class="sig-param"><span class="n">synapse</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">function</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">transform</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">learning_rule_type</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">eval_points</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">scale_eval_points</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">label</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">Default</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/connection.py#L329-L664"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects two objects together.</p>
<p>The connection between the two object is unidirectional,
transmitting information from the first argument, <code class="docutils literal notranslate"><span class="pre">pre</span></code>,
to the second argument, <code class="docutils literal notranslate"><span class="pre">post</span></code>.</p>
<p>Almost any Nengo object can act as the pre or post side of a connection.
Additionally, you can use Python slice syntax to access only some of the
dimensions of the pre or post object.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">node</span></code> has <code class="docutils literal notranslate"><span class="pre">size_out=2</span></code> and <code class="docutils literal notranslate"><span class="pre">ensemble</span></code> has
<code class="docutils literal notranslate"><span class="pre">size_in=1</span></code>:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">ensemble</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We could not create the following connection:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<p>But, we could create either of these two connections:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">net</span><span class="p">:</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ensemble</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>pre</strong><span class="classifier">Ensemble or Neurons or Node</span></dt><dd><p>The source Nengo object for the connection.</p>
</dd>
<dt><strong>post</strong><span class="classifier">Ensemble or Neurons or Node or LearningRule</span></dt><dd><p>The destination object for the connection.</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse or None, optional</span></dt><dd><p>Synapse model to use for filtering (see <a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>).
If <em>None</em>, no synapse will be used and information will be transmitted
without any delay (if supported by the backend—some backends may
introduce a single time step delay).</p>
<p>Note that at least one connection must have a synapse that is not
<em>None</em> if components are connected in a cycle. Furthermore, a synaptic
filter with a zero time constant is different from a <em>None</em> synapse
as a synaptic filter will always add a delay of at least one time step.</p>
</dd>
<dt><strong>function</strong><span class="classifier">callable or (n_eval_points, size_mid) array_like, optional</span></dt><dd><p>Function to compute across the connection. Note that <code class="docutils literal notranslate"><span class="pre">pre</span></code> must be
an ensemble to apply a function across the connection.
If an array is passed, the function is implicitly defined by the
points in the array and the provided <code class="docutils literal notranslate"><span class="pre">eval_points</span></code>, which have a
one-to-one correspondence.</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(size_out, size_mid) array_like, optional</span></dt><dd><p>Linear transform mapping the pre output to the post input.
This transform is in terms of the sliced size; if either pre
or post is a slice, the transform must be shaped according to
the sliced dimensionality. Additionally, the function is applied
before the transform, so if a function is computed across the
connection, the transform must be of shape <code class="docutils literal notranslate"><span class="pre">(size_out,</span> <span class="pre">size_mid)</span></code>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver, optional</span></dt><dd><p>Solver instance to compute decoders or weights
(see <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a>). If <code class="docutils literal notranslate"><span class="pre">solver.weights</span></code> is True, a full
connection weight matrix is computed instead of decoders.</p>
</dd>
<dt><strong>learning_rule_type</strong><span class="classifier">LearningRuleType or iterable of LearningRuleType, optional</span></dt><dd><p>Modifies the decoders or connection weights during simulation.</p>
</dd>
<dt><strong>eval_points</strong><span class="classifier">(n_eval_points, size_in) array_like or int, optional</span></dt><dd><p>Points at which to evaluate <code class="docutils literal notranslate"><span class="pre">function</span></code> when computing decoders,
spanning the interval (-pre.radius, pre.radius) in each dimension.
If None, will use the eval_points associated with <code class="docutils literal notranslate"><span class="pre">pre</span></code>.</p>
</dd>
<dt><strong>scale_eval_points</strong><span class="classifier">bool, optional</span></dt><dd><p>Indicates whether the evaluation points should be scaled
by the radius of the pre Ensemble.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A descriptive label for the connection.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>function</strong><span class="classifier">callable</span></dt><dd><p>The given function.</p>
</dd>
<dt><strong>function_size</strong><span class="classifier">int</span></dt><dd><p>The output dimensionality of the given function. If no function is
specified, function_size will be 0.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str</span></dt><dd><p>A human-readable connection label for debugging and visualization.
If not overridden, incorporates the labels of the pre and post objects.</p>
</dd>
<dt><strong>learning_rule_type</strong><span class="classifier">instance or list or dict of LearningRuleType, optional</span></dt><dd><p>The learning rule types.</p>
</dd>
<dt><strong>post</strong><span class="classifier">Ensemble or Neurons or Node or Probe or ObjView</span></dt><dd><p>The given post object.</p>
</dd>
<dt><strong>post_obj</strong><span class="classifier">Ensemble or Neurons or Node or Probe</span></dt><dd><p>The underlying post object, even if <code class="docutils literal notranslate"><span class="pre">post</span></code> is an <code class="docutils literal notranslate"><span class="pre">ObjView</span></code>.</p>
</dd>
<dt><strong>post_slice</strong><span class="classifier">slice or list or None</span></dt><dd><p>The slice associated with <code class="docutils literal notranslate"><span class="pre">post</span></code> if it is an ObjView, or None.</p>
</dd>
<dt><strong>pre</strong><span class="classifier">Ensemble or Neurons or Node or ObjView</span></dt><dd><p>The given pre object.</p>
</dd>
<dt><strong>pre_obj</strong><span class="classifier">Ensemble or Neurons or Node</span></dt><dd><p>The underlying pre object, even if <code class="docutils literal notranslate"><span class="pre">post</span></code> is an <code class="docutils literal notranslate"><span class="pre">ObjView</span></code>.</p>
</dd>
<dt><strong>pre_slice</strong><span class="classifier">slice or list or None</span></dt><dd><p>The slice associated with <code class="docutils literal notranslate"><span class="pre">pre</span></code> if it is an ObjView, or None.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver</span></dt><dd><p>The Solver instance that will be used to compute decoders or weights
(see <code class="docutils literal notranslate"><span class="pre">nengo.solvers</span></code>).</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse</span></dt><dd><p>The Synapse model used for filtering across the connection
(see <code class="docutils literal notranslate"><span class="pre">nengo.synapses</span></code>).</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(size_out, size_mid) array_like</span></dt><dd><p>Linear transform mapping the pre function output to the post input.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Connection.learning_rule">
<em class="property">property </em><code class="sig-name descname">learning_rule</code><a class="headerlink" href="#nengo.Connection.learning_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>(LearningRule or iterable) Connectable learning rule object(s).</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Connection.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.Connection.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the pre object.</p>
<p>Also the input size of the function, if one is specified.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Connection.size_mid">
<em class="property">property </em><code class="sig-name descname">size_mid</code><a class="headerlink" href="#nengo.Connection.size_mid" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of output dimensions of the function, if specified.</p>
<p>If the function is not specified, then <code class="docutils literal notranslate"><span class="pre">size_in</span> <span class="pre">==</span> <span class="pre">size_mid</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Connection.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.Connection.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) The number of input dimensions of the post object.</p>
<p>Also the number of output dimensions of the transform.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.connection.LearningRule">
<em class="property">class </em><code class="sig-prename descclassname">nengo.connection.</code><code class="sig-name descname">LearningRule</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">connection</span></em>, <em class="sig-param"><span class="n">learning_rule_type</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/connection.py#L667-L752"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.connection.LearningRule" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface for making connections to a learning rule.</p>
<p>Connections to a learning rule are to allow elements of the network to
affect the learning rule. For example, learning rules that use error
information can obtain that information through a connection.</p>
<p>Learning rule objects should only ever be accessed through the
<code class="docutils literal notranslate"><span class="pre">learning_rule</span></code> attribute of a connection.</p>
<dl class="py method">
<dt id="nengo.connection.LearningRule.connection">
<em class="property">property </em><code class="sig-name descname">connection</code><a class="headerlink" href="#nengo.connection.LearningRule.connection" title="Permalink to this definition">¶</a></dt>
<dd><p>(Connection) The connection modified by the learning rule.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.connection.LearningRule.modifies">
<em class="property">property </em><code class="sig-name descname">modifies</code><a class="headerlink" href="#nengo.connection.LearningRule.modifies" title="Permalink to this definition">¶</a></dt>
<dd><p>(str) The variable modified by the learning rule.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.connection.LearningRule.probeable">
<em class="property">property </em><code class="sig-name descname">probeable</code><a class="headerlink" href="#nengo.connection.LearningRule.probeable" title="Permalink to this definition">¶</a></dt>
<dd><p>(tuple) Signals that can be probed in the learning rule.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.connection.LearningRule.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.connection.LearningRule.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from learning rules, so always 0.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Probe">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Probe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">target</span></em>, <em class="sig-param"><span class="n">attr</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sample_every</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">synapse</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">label</span><span class="o">=</span><span class="default_value">Default</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">Default</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/probe.py#L50-L170"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Probe" title="Permalink to this definition">¶</a></dt>
<dd><p>A probe is an object that collects data from the simulation.</p>
<p>This is to be used in any situation where you wish to gather simulation
data (spike data, represented values, neuron voltages, etc.) for analysis.</p>
<p>Probes do not directly affect the simulation.</p>
<p>All Nengo objects can be probed (except Probes themselves).
Each object has different attributes that can be probed.
To see what is probeable for each object, print its
<code class="docutils literal notranslate"><span class="pre">probeable</span></code> attribute.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">():</span>
    <span class="n">ens</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ens</span><span class="o">.</span><span class="n">probeable</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(&#39;decoded_output&#39;, &#39;input&#39;, &#39;scaled_encoders&#39;)
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>target</strong><span class="classifier">Ensemble, Neurons, Node, or Connection</span></dt><dd><p>The object to probe.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">str, optional</span></dt><dd><p>The signal to probe. Refer to the target’s <code class="docutils literal notranslate"><span class="pre">probeable</span></code> list for
details. If None, the first element in the <code class="docutils literal notranslate"><span class="pre">probeable</span></code> list
will be used.</p>
</dd>
<dt><strong>sample_every</strong><span class="classifier">float, optional</span></dt><dd><p>Sampling period in seconds. If None, the <code class="docutils literal notranslate"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse, optional</span></dt><dd><p>A synaptic model to filter the probed signal.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver, optional</span></dt><dd><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a> to compute decoders
for probes that require them.</p>
</dd>
<dt><strong>label</strong><span class="classifier">str, optional</span></dt><dd><p>A name for the probe. Used for debugging and visualization.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>The seed used for random number generation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>attr</strong><span class="classifier">str or None</span></dt><dd><p>The signal that will be probed. If None, the first element of the
target’s <code class="docutils literal notranslate"><span class="pre">probeable</span></code> list will be used.</p>
</dd>
<dt><strong>sample_every</strong><span class="classifier">float or None</span></dt><dd><p>Sampling period in seconds. If None, the <code class="docutils literal notranslate"><span class="pre">dt</span></code> of the simluation
will be used.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">Solver or None</span></dt><dd><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a> to compute decoders. Only used for probes
of an ensemble’s decoded output.</p>
</dd>
<dt><strong>synapse</strong><span class="classifier">Synapse or None</span></dt><dd><p>A synaptic model to filter the probed signal.</p>
</dd>
<dt><strong>target</strong><span class="classifier">Ensemble, Neurons, Node, or Connection</span></dt><dd><p>The object to probe.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Probe.obj">
<em class="property">property </em><code class="sig-name descname">obj</code><a class="headerlink" href="#nengo.Probe.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>(Nengo object) The underlying Nengo object target.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Probe.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.Probe.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Dimensionality of the probed signal.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Probe.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.Probe.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>(int) Cannot connect from probes, so always 0.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Probe.slice">
<em class="property">property </em><code class="sig-name descname">slice</code><a class="headerlink" href="#nengo.Probe.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>(slice) The slice associated with the Nengo object target.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nengo.dists">
<span id="distributions"></span><h2>Distributions<a class="headerlink" href="#module-nengo.dists" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Distribution</span></code></a></p></td>
<td><p>A base class for probability distributions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.get_samples" title="nengo.dists.get_samples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.get_samples</span></code></a></p></td>
<td><p>Convenience function to sample a distribution or return samples.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.PDF" title="nengo.dists.PDF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.PDF</span></code></a></p></td>
<td><p>An arbitrary distribution from a PDF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.Uniform" title="nengo.dists.Uniform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Uniform</span></code></a></p></td>
<td><p>A uniform distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Gaussian" title="nengo.dists.Gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Gaussian</span></code></a></p></td>
<td><p>A Gaussian distribution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.Exponential" title="nengo.dists.Exponential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Exponential</span></code></a></p></td>
<td><p>An exponential distribution (optionally with high values clipped).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.UniformHypersphere" title="nengo.dists.UniformHypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.UniformHypersphere</span></code></a></p></td>
<td><p>Uniform distribution on or in an n-dimensional unit hypersphere.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.QuasirandomSequence" title="nengo.dists.QuasirandomSequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.QuasirandomSequence</span></code></a></p></td>
<td><p>Sequence for quasi Monte Carlo sampling the <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>-cube.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.ScatteredHypersphere" title="nengo.dists.ScatteredHypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.ScatteredHypersphere</span></code></a></p></td>
<td><p>Quasirandom distribution over the hypersphere or hyperball.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.Choice" title="nengo.dists.Choice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Choice</span></code></a></p></td>
<td><p>Discrete distribution across a set of possible values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.Samples" title="nengo.dists.Samples"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.Samples</span></code></a></p></td>
<td><p>A set of samples.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SqrtBeta</span></code></a></p></td>
<td><p>Distribution of the square root of a Beta distributed random variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SubvectorLength</span></code></a></p></td>
<td><p>Distribution of the length of a subvectors of a unit vector.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.dists.CosineSimilarity" title="nengo.dists.CosineSimilarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.CosineSimilarity</span></code></a></p></td>
<td><p>Distribution of the cosine of the angle between two random vectors.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.dists.Distribution">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Distribution</code><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L22-L54"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for probability distributions.</p>
<p>The only thing that a probabilities distribution need to define is a
<a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution.sample</span></code></a> method. This base class ensures that all
distributions accept the same arguments for the sample function.</p>
<dl class="py method">
<dt id="nengo.dists.Distribution.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L34-L54"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Distribution.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.DistributionParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">DistributionParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L57-L64"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.DistributionParam" title="Permalink to this definition">¶</a></dt>
<dd><p>A Distribution.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.dists.DistOrArrayParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">DistOrArrayParam</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">default=Unconfigurable</em>, <em class="sig-param">sample_shape=None</em>, <em class="sig-param">sample_dtype=&lt;class 'numpy.float64'&gt;</em>, <em class="sig-param">optional=False</em>, <em class="sig-param">readonly=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L67-L91"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.DistOrArrayParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Can be a Distribution or samples from a distribution.</p>
</dd></dl>

<dl class="py function">
<dt id="nengo.dists.get_samples">
<code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">get_samples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist_or_samples</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L94-L139"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.get_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to sample a distribution or return samples.</p>
<p>Use this function in situations where you accept an argument that could
be a distribution, or could be an <code class="docutils literal notranslate"><span class="pre">array_like</span></code> of samples.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>dist_or_samples</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or (n, d) array_like</span></dt><dd><p>Source of the samples to be returned.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState, optional</span></dt><dd><p>Random number generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n, d) array_like</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nengo.dists</span> <span class="kn">import</span> <span class="n">get_samples</span>

<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">get_samples</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>

<span class="n">mean</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">mean</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>2.5000
0.0598
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="nengo.dists.PDF">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">PDF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L142-L180"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.PDF" title="Permalink to this definition">¶</a></dt>
<dd><p>An arbitrary distribution from a PDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">vector_like (n,)</span></dt><dd><p>Values of the points to sample from (interpolated).</p>
</dd>
<dt><strong>p</strong><span class="classifier">vector_like (n,)</span></dt><dd><p>Probabilities of the <code class="docutils literal notranslate"><span class="pre">x</span></code> points.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.PDF.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L178-L180"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.PDF.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.Uniform">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Uniform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">low</span></em>, <em class="sig-param"><span class="n">high</span></em>, <em class="sig-param"><span class="n">integer</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L183-L218"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>A uniform distribution.</p>
<p>It’s equally likely to get any scalar between <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code>.</p>
<p>Note that the order of <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> doesn’t matter;
if <code class="docutils literal notranslate"><span class="pre">low</span> <span class="pre">&lt;</span> <span class="pre">high</span></code> this will still work, and <code class="docutils literal notranslate"><span class="pre">low</span></code> will still
be a closed interval while <code class="docutils literal notranslate"><span class="pre">high</span></code> is open.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>low</strong><span class="classifier">Number</span></dt><dd><p>The closed lower bound of the uniform distribution; samples &gt;= low</p>
</dd>
<dt><strong>high</strong><span class="classifier">Number</span></dt><dd><p>The open upper bound of the uniform distribution; samples &lt; high</p>
</dd>
<dt><strong>integer</strong><span class="classifier">boolean, optional</span></dt><dd><p>If true, sample from a uniform distribution of integers. In this case,
low and high should be integers.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.Uniform.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L213-L218"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Uniform.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.Gaussian">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Gaussian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mean</span></em>, <em class="sig-param"><span class="n">std</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L221-L250"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>A Gaussian distribution.</p>
<p>This represents a bell-curve centred at <code class="docutils literal notranslate"><span class="pre">mean</span></code> and with
spread represented by the standard deviation, <code class="docutils literal notranslate"><span class="pre">std</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mean</strong><span class="classifier">Number</span></dt><dd><p>The mean of the Gaussian.</p>
</dd>
<dt><strong>std</strong><span class="classifier">Number</span></dt><dd><p>The standard deviation of the Gaussian.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValidationError if std is &lt;= 0</dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.Gaussian.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L248-L250"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Gaussian.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.Exponential">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Exponential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scale</span></em>, <em class="sig-param"><span class="n">shift</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">high</span><span class="o">=</span><span class="default_value">inf</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L253-L299"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>An exponential distribution (optionally with high values clipped).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">high</span></code> is left to its default value of infinity, this is a standard
exponential distribution. If <code class="docutils literal notranslate"><span class="pre">high</span></code> is set, then any sampled values at
or above <code class="docutils literal notranslate"><span class="pre">high</span></code> will be clipped so they are slightly below <code class="docutils literal notranslate"><span class="pre">high</span></code>.
This is useful for thresholding.</p>
<p>The probability distribution function (PDF) is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">shift</span>
<span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="n">scale</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>  <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">shift</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">high</span>
       <span class="o">|</span>  <span class="n">n</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">high</span> <span class="o">-</span> <span class="n">eps</span>
       <span class="o">|</span>  <span class="mi">0</span>                                 <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">high</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is such that the PDF integrates to one, and <code class="docutils literal notranslate"><span class="pre">eps</span></code> is an
infinitesimally small number such that samples of <code class="docutils literal notranslate"><span class="pre">x</span></code> are strictly less
than <code class="docutils literal notranslate"><span class="pre">high</span></code> (in practice, <code class="docutils literal notranslate"><span class="pre">eps</span></code> depends on floating point precision).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float</span></dt><dd><p>The scale parameter (inverse of the rate parameter lambda). Larger
values make the distribution narrower (sharper peak).</p>
</dd>
<dt><strong>shift</strong><span class="classifier">float, optional</span></dt><dd><p>Amount to shift the distribution by. There will be no values smaller
than this shift when sampling from the distribution.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float, optional</span></dt><dd><p>All values larger than or equal to this value will be clipped to
slightly less than this value.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.Exponential.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L295-L299"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Exponential.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.UniformHypersphere">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">UniformHypersphere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">surface</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">min_magnitude</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L302-L347"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.UniformHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniform distribution on or in an n-dimensional unit hypersphere.</p>
<p>Sample points are uniformly distributed across the volume (default) or
surface of an n-dimensional unit hypersphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>surface</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether sample points should be distributed uniformly
over the surface of the hyperphere (True),
or within the hypersphere (False).</p>
</dd>
<dt><strong>min_magnitude</strong><span class="classifier">Number, optional</span></dt><dd><p>Lower bound on the returned vector magnitudes (such that they are in
the range <code class="docutils literal notranslate"><span class="pre">[min_magnitude,</span> <span class="pre">1]</span></code>). Must be in the range [0, 1).
Ignored if <code class="docutils literal notranslate"><span class="pre">surface</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.UniformHypersphere.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L330-L347"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.UniformHypersphere.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.QuasirandomSequence">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">QuasirandomSequence</code><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L350-L411"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.QuasirandomSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequence for quasi Monte Carlo sampling the <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>-cube.</p>
<p>This is similar to <code class="docutils literal notranslate"><span class="pre">np.random.uniform(0,</span> <span class="pre">1,</span> <span class="pre">size=(num,</span> <span class="pre">d))</span></code>, but with the
additional property that each <code class="docutils literal notranslate"><span class="pre">d</span></code>-dimensional point is uniformly scattered.</p>
<p>While the sequence is defined deterministically, we introduce two stochastic
elements to encourage heterogeneity in models using these sequences.
First, we offset the start of the sequence by a random number between 0 and 1
to ensure we don’t oversample points aligned to the step size.
Second, we shuffle the resulting sequence before returning to ensure we don’t
introduce correlations between parameters sampled from this distribution.</p>
<p>This is based on the tutorial and code from <a class="footnote-reference brackets" href="#id2" id="id1">1</a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.ScatteredHypersphere" title="nengo.dists.ScatteredHypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScatteredHypersphere</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Martin Roberts. “The Unreasonable Effectiveness of Quasirandom Sequences.”
<a class="reference external" href="http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/">http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">rd</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">QuasirandomSequence</span><span class="p">()</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rd</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Blues&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="nengo.dists.QuasirandomSequence.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L397-L411"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.QuasirandomSequence.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.ScatteredHypersphere">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">ScatteredHypersphere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">surface</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">min_magnitude</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">base</span><span class="o">=</span><span class="default_value">QuasirandomSequence()</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'sct-approx'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L414-L646"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.ScatteredHypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Quasirandom distribution over the hypersphere or hyperball.</p>
<p>Applies a spherical transform to the given quasirandom sequence
(by default <a class="reference internal" href="#nengo.dists.QuasirandomSequence" title="nengo.dists.QuasirandomSequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuasirandomSequence</span></code></a>) to obtain uniformly scattered samples.</p>
<p>This distribution has the nice mathematical property that the discrepancy
between the empirical distribution and <span class="math notranslate nohighlight">\(n\)</span> samples is
<span class="math notranslate nohighlight">\(\widetilde{\mathcal{O}} (1 / n)\)</span> as opposed to
<span class="math notranslate nohighlight">\(\mathcal{O} (1 / \sqrt{n})\)</span> for the Monte Carlo method <a class="reference internal" href="#r8ab4b6a980c5-1" id="id3">[1]</a>.
This means that the number of samples is effectively squared, making this
useful as a means for sampling <code class="docutils literal notranslate"><span class="pre">eval_points</span></code> and <code class="docutils literal notranslate"><span class="pre">encoders</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>surface</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether sample points should be distributed uniformly
over the surface of the hyperphere (True),
or within the hypersphere (False).</p>
</dd>
<dt><strong>min_magnitude</strong><span class="classifier">Number, optional</span></dt><dd><p>Lower bound on the returned vector magnitudes (such that they are in
the range <code class="docutils literal notranslate"><span class="pre">[min_magnitude,</span> <span class="pre">1]</span></code>). Must be in the range [0, 1).
Ignored if <code class="docutils literal notranslate"><span class="pre">surface</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
<dt><strong>base</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a>, optional</span></dt><dd><p>The base distribution from which to sample quasirandom numbers.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{“sct-approx”, “sct”, “tfww”}</span></dt><dd><p>Method to use for mapping points to the hypersphere.</p>
<ul class="simple">
<li><p>“sct-approx”: Same as “sct”, but uses lookup table to approximate the
beta distribution, making it faster with almost exactly the same result.</p></li>
<li><p>“sct”: Use the exact Spherical Coordinate Transform
(section 1.5.2 of <a class="reference internal" href="#r8ab4b6a980c5-1" id="id4">[1]</a>).</p></li>
<li><p>“tfww”: Use the Tashiro-Fang-Wang-Wong method (section 4.3 of <a class="reference internal" href="#r8ab4b6a980c5-1" id="id5">[1]</a>).
Faster than “sct” and “sct-approx”, with the same level of uniformity
for larger numbers of samples (<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">4000</span></code>, approximately).</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.UniformHypersphere" title="nengo.dists.UniformHypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UniformHypersphere</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#nengo.dists.QuasirandomSequence" title="nengo.dists.QuasirandomSequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuasirandomSequence</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <a class="reference internal" href="#nengo.dists.QuasirandomSequence" title="nengo.dists.QuasirandomSequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuasirandomSequence</span></code></a> distribution is mostly deterministic.
Nondeterminism comes from a random <code class="docutils literal notranslate"><span class="pre">d</span></code>-dimensional rotation.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8ab4b6a980c5-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>K.-T. Fang and Y. Wang, Number-Theoretic Methods in Statistics.
Chapman &amp; Hall, 1994.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot points sampled from the surface of the sphere in 3 dimensions:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="n">points</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">ScatteredHypersphere</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s2">&quot;3d&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot points sampled from the volume of the sphere in 2 dimensions (i.e. circle):</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">dists</span><span class="o">.</span><span class="n">ScatteredHypersphere</span><span class="p">(</span><span class="n">surface</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="nengo.dists.ScatteredHypersphere.spherical_transform_sct">
<em class="property">classmethod </em><code class="sig-name descname">spherical_transform_sct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em>, <em class="sig-param"><span class="n">approx</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L524-L547"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.ScatteredHypersphere.spherical_transform_sct" title="Permalink to this definition">¶</a></dt>
<dd><p>Map samples from the <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>-cube onto the hypersphere.</p>
<p>Uses the SCT method described in section 1.5.3 of Fang and Wang (1994).</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.ScatteredHypersphere.spherical_transform_tfww">
<em class="property">static </em><code class="sig-name descname">spherical_transform_tfww</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">c_samples</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L549-L596"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.ScatteredHypersphere.spherical_transform_tfww" title="Permalink to this definition">¶</a></dt>
<dd><p>Map samples from the <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>-cube onto the hypersphere surface.</p>
<p>Uses the TFWW method described in section 4.3 of Fang and Wang (1994).</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.ScatteredHypersphere.random_orthogonal">
<em class="property">static </em><code class="sig-name descname">random_orthogonal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L598-L603"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.ScatteredHypersphere.random_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random orthogonal matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.ScatteredHypersphere.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L605-L646"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.ScatteredHypersphere.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.Choice">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Choice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">options</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L649-L709"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Choice" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete distribution across a set of possible values.</p>
<p>The same as Numpy random’s <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.RandomState.choice.html#numpy.random.RandomState.choice" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choice</span></code></a>,
except can take vector or matrix values for the choices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>options</strong><span class="classifier">(N, …) array_like</span></dt><dd><p>The options (choices) to choose between. The choice is always done
along the first axis, so if <code class="docutils literal notranslate"><span class="pre">options</span></code> is a matrix, the options are
the rows of that matrix.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Weights controlling the probability of selecting each option. Will
automatically be normalized. If None, weights be uniformly distributed.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.Choice.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L699-L709"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Choice.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.Samples">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">Samples</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">samples</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L712-L765"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Samples" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of samples.</p>
<p>This class is a subclass of <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> so that it can be used in any
situation that calls for a  <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a>. However, the call to
<a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution.sample</span></code></a> must match the dimensions of the samples or
a <a class="reference internal" href="backend-api.html#nengo.exceptions.ValidationError" title="nengo.exceptions.ValidationError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ValidationError</span></code></a> will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n, d) array_like</span></dt><dd><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> must match what is eventually passed to</dt><dd><p><a class="reference internal" href="#nengo.dists.Distribution.sample" title="nengo.dists.Distribution.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution.sample</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.dists.Samples.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L733-L765"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.Samples.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.SqrtBeta">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">SqrtBeta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">m</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L768-L862"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the square root of a Beta distributed random variable.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">m</span></code> dimensional random unit vectors, the length of subvectors
with <code class="docutils literal notranslate"><span class="pre">m</span></code> elements will be distributed according to this distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n: int</strong></dt><dd><p>Number of subvectors.</p>
</dd>
<dt><strong>m: int, optional</strong></dt><dd><p>Length of each subvector.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.SubvectorLength" title="nengo.dists.SubvectorLength"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SubvectorLength</span></code></a></dt><dd></dd>
</dl>
</div>
<dl class="py method">
<dt id="nengo.dists.SqrtBeta.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">num</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L794-L796"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.SqrtBeta.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L798-L818"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability that <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.SqrtBeta.pdf">
<code class="sig-name descname">pdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L820-L842"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability density at <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.SqrtBeta.ppf">
<code class="sig-name descname">ppf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L844-L862"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SqrtBeta.ppf" title="Permalink to this definition">¶</a></dt>
<dd><p>Percent point function (inverse cumulative distribution).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Cumulative probabilities in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ppf</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0, 1] such that <code class="docutils literal notranslate"><span class="pre">P(X</span> <span class="pre">&lt;=</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.dists.SubvectorLength">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">SubvectorLength</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimensions</span></em>, <em class="sig-param"><span class="n">subdimensions</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L865-L889"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.SubvectorLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the length of a subvectors of a unit vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions</strong><span class="classifier">int</span></dt><dd><p>Dimensionality of the complete unit vector.</p>
</dd>
<dt><strong>subdimensions</strong><span class="classifier">int, optional</span></dt><dd><p>Dimensionality of the subvector.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SqrtBeta</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py class">
<dt id="nengo.dists.CosineSimilarity">
<em class="property">class </em><code class="sig-prename descclassname">nengo.dists.</code><code class="sig-name descname">CosineSimilarity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimensions</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L892-L946"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribution of the cosine of the angle between two random vectors.</p>
<p>The “cosine similarity” is the cosine of the angle between two vectors,
which is equal to the dot product of the vectors, divided by the L2-norms
of the individual vectors. When these vectors are unit length, this is then
simply the distribution of their dot product.</p>
<p>This is also equivalent to the distribution of a single coefficient from a
unit vector (a single dimension of <code class="docutils literal notranslate"><span class="pre">UniformHypersphere(surface=True)</span></code>).
Furthermore, <code class="docutils literal notranslate"><span class="pre">CosineSimilarity(d+2)</span></code> is equivalent to the distribution of
a single coordinate from points uniformly sampled from the d-dimensional
unit ball (a single dimension of
<code class="docutils literal notranslate"><span class="pre">UniformHypersphere(surface=False).sample(n,</span> <span class="pre">d)</span></code>). These relationships
have been detailed in <a class="reference internal" href="#r0dd7d02f1d08-voelker2017" id="id7">[Voelker2017]</a>.</p>
<p>This can be used to calculate an intercept <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> such that
<code class="docutils literal notranslate"><span class="pre">dot(u,</span> <span class="pre">v)</span> <span class="pre">&gt;=</span> <span class="pre">c</span></code> with probability <code class="docutils literal notranslate"><span class="pre">p</span></code>, for random unit vectors <code class="docutils literal notranslate"><span class="pre">u</span></code>
and <code class="docutils literal notranslate"><span class="pre">v</span></code>. In other words, a neuron with intercept <code class="docutils literal notranslate"><span class="pre">ppf(1</span> <span class="pre">-</span> <span class="pre">p)</span></code> will
fire with probability <code class="docutils literal notranslate"><span class="pre">p</span></code> for a random unit length input.</p>
<dl class="citation">
<dt class="label" id="r0dd7d02f1d08-voelker2017"><span class="brackets"><a class="fn-backref" href="#id7">Voelker2017</a></span></dt>
<dd><p><a class="reference external" href="http://compneuro.uwaterloo.ca/publications/voelker2017.html">Aaron R. Voelker, Jan Gosmann, and Terrence C. Stewart.
Efficiently sampling vectors and coordinates from the n-sphere and
n-ball. Technical Report, Centre for Theoretical Neuroscience,
Waterloo, ON, 2017</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dimensions: int</strong></dt><dd><p>Dimensionality of the complete unit vector.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.dists.SqrtBeta" title="nengo.dists.SqrtBeta"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.dists.SqrtBeta</span></code></a></dt><dd></dd>
</dl>
</div>
<dl class="py method">
<dt id="nengo.dists.CosineSimilarity.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">num</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L933-L936"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Samples the distribution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Number samples to take.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of dimensions to return. If this is an int, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>. If None, the return
value will be of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(n,) or (n, d) array_like</span></dt><dd><p>Samples as a 1d or 2d array depending on <code class="docutils literal notranslate"><span class="pre">d</span></code>. The second
dimension enumerates the dimensions of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.CosineSimilarity.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L938-L939"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cumulative distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability that <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&lt;=</span> <span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.CosineSimilarity.pdf">
<code class="sig-name descname">pdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L941-L942"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.pdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability distribution function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pdf</strong><span class="classifier">array_like</span></dt><dd><p>Probability density at <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.dists.CosineSimilarity.ppf">
<code class="sig-name descname">ppf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/dists.py#L944-L946"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.dists.CosineSimilarity.ppf" title="Permalink to this definition">¶</a></dt>
<dd><p>Percent point function (inverse cumulative distribution).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires SciPy.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array_like</span></dt><dd><p>Cumulative probabilities in [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ppf</strong><span class="classifier">array_like</span></dt><dd><p>Evaluation points <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0, 1] such that <code class="docutils literal notranslate"><span class="pre">P(X</span> <span class="pre">&lt;=</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nengo.learning_rules">
<span id="learning-rule-types"></span><h2>Learning rule types<a class="headerlink" href="#module-nengo.learning_rules" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.learning_rules.LearningRuleType" title="nengo.learning_rules.LearningRuleType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.learning_rules.LearningRuleType</span></code></a></p></td>
<td><p>Base class for all learning rule objects.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.PES</span></code></a></p></td>
<td><p>Prescribed Error Sensitivity learning rule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.RLS" title="nengo.RLS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.RLS</span></code></a></p></td>
<td><p>Recursive least-squares rule for online decoder optimization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.BCM" title="nengo.BCM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.BCM</span></code></a></p></td>
<td><p>Bienenstock-Cooper-Munroe learning rule.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Oja" title="nengo.Oja"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Oja</span></code></a></p></td>
<td><p>Oja learning rule.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Voja" title="nengo.Voja"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Voja</span></code></a></p></td>
<td><p>Vector Oja learning rule.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.learning_rules.LearningRuleTypeSizeInParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.learning_rules.</code><code class="sig-name descname">LearningRuleTypeSizeInParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">low</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">high</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">low_open</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">high_open</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L10-L24"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.learning_rules.LearningRuleTypeSizeInParam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="nengo.learning_rules.LearningRuleType">
<em class="property">class </em><code class="sig-prename descclassname">nengo.learning_rules.</code><code class="sig-name descname">LearningRuleType</code><span class="sig-paren">(</span><em class="sig-param">learning_rate=Default&lt;1e-06&gt;</em>, <em class="sig-param">size_in=0</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L27-L83"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.learning_rules.LearningRuleType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all learning rule objects.</p>
<p>To use a learning rule, pass it as a <code class="docutils literal notranslate"><span class="pre">learning_rule_type</span></code> keyword
argument to the <a class="reference internal" href="#nengo.Connection" title="nengo.Connection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connection</span></code></a> on which you want to do learning.</p>
<p>Each learning rule exposes two important pieces of metadata that the
builder uses to determine what information should be stored.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">size_in</span></code> is the dimensionality of the incoming error signal. It
can either take an integer or one of the following string values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'pre'</span></code>: vector error signal in pre-object space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'post'</span></code>: vector error signal in post-object space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'mid'</span></code>: vector error signal in the <code class="docutils literal notranslate"><span class="pre">conn.size_mid</span></code> space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'pre_state'</span></code>: vector error signal in pre-synaptic ensemble space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'post_state'</span></code>: vector error signal in post-synaptic ensemble space</p></li>
</ul>
<p>The difference between <code class="docutils literal notranslate"><span class="pre">'post_state'</span></code> and <code class="docutils literal notranslate"><span class="pre">'post'</span></code> is that with the
former, if a <code class="docutils literal notranslate"><span class="pre">Neurons</span></code> object is passed, it will use the dimensionality
of the corresponding <code class="docutils literal notranslate"><span class="pre">Ensemble</span></code>, whereas the latter simply uses the
<code class="docutils literal notranslate"><span class="pre">post</span></code> object <code class="docutils literal notranslate"><span class="pre">size_in</span></code>. Similarly with <code class="docutils literal notranslate"><span class="pre">'pre_state'</span></code> and <code class="docutils literal notranslate"><span class="pre">'pre'</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">modifies</span></code> attribute denotes the signal targeted by the rule.
Options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'encoders'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'decoders'</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'weights'</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which <code class="docutils literal notranslate"><span class="pre">modifies</span></code> will be adjusted.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int, str, optional</span></dt><dd><p>Dimensionality of the error signal (see above).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which <code class="docutils literal notranslate"><span class="pre">modifies</span></code> will be adjusted.</p>
</dd>
<dt><strong>size_in</strong><span class="classifier">int, str</span></dt><dd><p>Dimensionality of the error signal.</p>
</dd>
<dt><strong>modifies</strong><span class="classifier">str</span></dt><dd><p>The signal targeted by the learning rule.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.PES">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">PES</code><span class="sig-paren">(</span><em class="sig-param">learning_rate=Default&lt;0.0001&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L86-L121"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.PES" title="Permalink to this definition">¶</a></dt>
<dd><p>Prescribed Error Sensitivity learning rule.</p>
<p>Modifies a connection’s decoders to minimize an error signal provided
through a connection to the connection’s learning rule.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.RLS">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">RLS</code><span class="sig-paren">(</span><em class="sig-param">learning_rate=Default&lt;0.001&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L124-L233"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RLS" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive least-squares rule for online decoder optimization.</p>
<p>This implements an online version of the standard least-squares solvers used
to learn connection weights offline (e.g. <a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL2</span></code></a>). It can be
applied in the same scenarios as <a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PES</span></code></a>, to minimize an error signal.</p>
<p>The cost of RLS is <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> extra time and memory. If possible,
it is more efficient to do the learning offline using e.g. <a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LstsqL2</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>Effective learning rate. This is better understood as
<span class="math notranslate nohighlight">\(\frac{1}{\alpha}\)</span>, where <span class="math notranslate nohighlight">\(\alpha\)</span> is an L2-regularization
term. A large learning rate means little regularization, which implies
quick over-fitting. A small learning rate means large regularization,
which translates to slower learning <a class="footnote-reference brackets" href="#id9" id="id8">2</a>.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier">Synapse, optional</span></dt><dd><p>Synapse model applied to the pre-synaptic neural activities.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.PES</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL2</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>RLS works by maintaining the inverse neural correlation matrix,
<span class="math notranslate nohighlight">\(P = \Gamma^{-1}\)</span>, where <span class="math notranslate nohighlight">\(\Gamma = A^T A + \alpha I\)</span> are the
regularized correlations, <span class="math notranslate nohighlight">\(A\)</span> is a matrix of (possibly filtered)
neural activities, and <span class="math notranslate nohighlight">\(\alpha\)</span> is an L2-regularization term
controlled by the <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code>. <span class="math notranslate nohighlight">\(P\)</span> is used to project the
error signal and update the weights each time-step.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id9"><span class="brackets"><a class="fn-backref" href="#id8">2</a></span></dt>
<dd><p>Sussillo, D., &amp; Abbott, L. F. (2009). Generating coherent patterns
of activity from chaotic neural networks. Neuron, 63(4), 544-557.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Below, we compare <a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PES</span></code></a> against <a class="reference internal" href="#nengo.RLS" title="nengo.RLS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RLS</span></code></a>, learning a feed-forward
communication channel (identity function) online, starting with 100 spiking
LIF neurons with decoders (weights) set to zero. A faster learning rate for
<a class="reference internal" href="#nengo.PES" title="nengo.PES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PES</span></code></a> results in over-fitting to the most recent online example, while a
slower learning rate does not learn quickly enough. This is a general problem
with greedy optimization. <a class="reference internal" href="#nengo.RLS" title="nengo.RLS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RLS</span></code></a> performs better since it is L2-optimal.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nengo.learning_rules</span> <span class="kn">import</span> <span class="n">PES</span><span class="p">,</span> <span class="n">RLS</span>

<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.005</span>
<span class="n">learning_rules</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">PES</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">pre_synapse</span><span class="o">=</span><span class="n">tau</span><span class="p">),</span>
    <span class="n">RLS</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">pre_synapse</span><span class="o">=</span><span class="n">tau</span><span class="p">),</span>
<span class="p">)</span>

<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">model</span><span class="p">:</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
    <span class="n">probes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">lr</span> <span class="ow">in</span> <span class="n">learning_rules</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">size_in</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">size_in</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">learning_rule_type</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">conn</span><span class="o">.</span><span class="n">learning_rule</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="n">tau</span><span class="p">))</span>
    <span class="n">probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">synapse</span><span class="o">=</span><span class="n">tau</span><span class="p">))</span>

<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">(),</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">probes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">learning_rules</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">(),</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">probes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">learning_rules</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">(),</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">probes</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Ideal&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Training -&gt; Testing&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="nengo.BCM">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">BCM</code><span class="sig-paren">(</span><em class="sig-param">learning_rate=Default&lt;1e-09&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">post_synapse=Default&lt;None&gt;</em>, <em class="sig-param">theta_synapse=Default&lt;Lowpass(tau=1.0)&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L243-L311"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.BCM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bienenstock-Cooper-Munroe learning rule.</p>
<p>Modifies connection weights as a function of the presynaptic activity
and the difference between the postsynaptic activity and the average
postsynaptic activity.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the post-synaptic activities.
If None, <code class="docutils literal notranslate"><span class="pre">post_synapse</span></code> will be the same as <code class="docutils literal notranslate"><span class="pre">pre_synapse</span></code>.</p>
</dd>
<dt><strong>theta_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the theta signal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The BCM rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the BCM rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the BCM rule by <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>theta_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the theta signal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.Oja">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Oja</code><span class="sig-paren">(</span><em class="sig-param">learning_rate=Default&lt;1e-06&gt;</em>, <em class="sig-param">pre_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em>, <em class="sig-param">post_synapse=Default&lt;None&gt;</em>, <em class="sig-param">beta=Default&lt;1.0&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L314-L381"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Oja" title="Permalink to this definition">¶</a></dt>
<dd><p>Oja learning rule.</p>
<p>Modifies connection weights according to the Hebbian Oja rule, which
augments typically Hebbian coactivity with a “forgetting” term that is
proportional to the weight of the connection and the square of the
postsynaptic activity.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the post-synaptic activities.
If None, <code class="docutils literal notranslate"><span class="pre">post_synapse</span></code> will be the same as <code class="docutils literal notranslate"><span class="pre">pre_synapse</span></code>.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar weight on the forgetting term.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Oja rule is dependent on pre and post neural activities,
not decoded values, and so is not affected by changes in the
size of pre and post ensembles. However, if you are decoding from
the post ensemble, the Oja rule will have an increased effect on
larger post ensembles because more connection weights are changing.
In these cases, it may be advantageous to scale the learning rate
on the Oja rule by <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">post.n_neurons</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>beta</strong><span class="classifier">float</span></dt><dd><p>A scalar weight on the forgetting term.</p>
</dd>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which weights will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
<dt><strong>pre_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the pre-synaptic activities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.Voja">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Voja</code><span class="sig-paren">(</span><em class="sig-param">learning_rate=Default&lt;0.01&gt;</em>, <em class="sig-param">post_synapse=Default&lt;Lowpass(tau=0.005)&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L384-L421"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Voja" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector Oja learning rule.</p>
<p>Modifies an ensemble’s encoders to be selective to its inputs.</p>
<p>A connection to the learning rule will provide a scalar weight for the
learning rate, minus 1. For instance, 0 is normal learning, -1 is no
learning, and less than -1 causes anti-learning or “forgetting”.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>post_tau</strong><span class="classifier">float, optional</span></dt><dd><p>Filter constant on activities of neurons in post population.</p>
</dd>
<dt><strong>learning_rate</strong><span class="classifier">float, optional</span></dt><dd><p>A scalar indicating the rate at which encoders will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a>, optional</span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>learning_rate</strong><span class="classifier">float</span></dt><dd><p>A scalar indicating the rate at which encoders will be adjusted.</p>
</dd>
<dt><strong>post_synapse</strong><span class="classifier"><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse</span></code></a></span></dt><dd><p>Synapse model used to filter the post-synaptic activities.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.learning_rules.LearningRuleTypeParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.learning_rules.</code><code class="sig-name descname">LearningRuleTypeParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/learning_rules.py#L424-L444"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.learning_rules.LearningRuleTypeParam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nengo.neurons">
<span id="neuron-types"></span><h2>Neuron types<a class="headerlink" href="#module-nengo.neurons" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.neurons.settled_firingrate" title="nengo.neurons.settled_firingrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.neurons.settled_firingrate</span></code></a></p></td>
<td><p>Compute firing rates (in Hz) for given vector input, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.neurons.NeuronType" title="nengo.neurons.NeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.neurons.NeuronType</span></code></a></p></td>
<td><p>Base class for Nengo neuron models.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Direct" title="nengo.Direct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Direct</span></code></a></p></td>
<td><p>Signifies that an ensemble should simulate in direct mode.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.RectifiedLinear" title="nengo.RectifiedLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.RectifiedLinear</span></code></a></p></td>
<td><p>A rectified linear neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.SpikingRectifiedLinear" title="nengo.SpikingRectifiedLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.SpikingRectifiedLinear</span></code></a></p></td>
<td><p>A rectified integrate and fire neuron model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Sigmoid" title="nengo.Sigmoid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Sigmoid</span></code></a></p></td>
<td><p>A non-spiking neuron model whose response curve is a sigmoid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Tanh" title="nengo.Tanh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Tanh</span></code></a></p></td>
<td><p>A non-spiking neuron model whose response curve is a hyperbolic tangent.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.LIFRate" title="nengo.LIFRate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.LIFRate</span></code></a></p></td>
<td><p>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.LIF" title="nengo.LIF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.LIF</span></code></a></p></td>
<td><p>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.AdaptiveLIFRate" title="nengo.AdaptiveLIFRate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.AdaptiveLIFRate</span></code></a></p></td>
<td><p>Adaptive non-spiking version of the LIF neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.AdaptiveLIF" title="nengo.AdaptiveLIF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.AdaptiveLIF</span></code></a></p></td>
<td><p>Adaptive spiking version of the LIF neuron model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Izhikevich" title="nengo.Izhikevich"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Izhikevich</span></code></a></p></td>
<td><p>Izhikevich neuron model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.neurons.RatesToSpikesNeuronType" title="nengo.neurons.RatesToSpikesNeuronType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.neurons.RatesToSpikesNeuronType</span></code></a></p></td>
<td><p>Base class for neuron types that turn rate types into spiking ones.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.RegularSpiking" title="nengo.RegularSpiking"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.RegularSpiking</span></code></a></p></td>
<td><p>Turn a rate neuron type into a spiking one with regular inter-spike intervals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.StochasticSpiking" title="nengo.StochasticSpiking"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.StochasticSpiking</span></code></a></p></td>
<td><p>Turn a rate neuron type into a spiking one using stochastic rounding.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.PoissonSpiking" title="nengo.PoissonSpiking"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.PoissonSpiking</span></code></a></p></td>
<td><p>Turn a rate neuron type into a spiking one with Poisson spiking statistics.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="nengo.neurons.settled_firingrate">
<code class="sig-prename descclassname">nengo.neurons.</code><code class="sig-name descname">settled_firingrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">step</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">state</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">settle_time</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">sim_time</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L12-L42"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.settled_firingrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute firing rates (in Hz) for given vector input, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Unlike the default naive implementation, this approach takes into
account some characteristics of spiking neurons. We start
by simulating the neurons for a short amount of time, to let any
initial transients settle. Then, we run the neurons for a second
and find the average (which should approximate the firing rate).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>step</strong><span class="classifier">function</span></dt><dd><p>the step function of the neuron type</p>
</dd>
<dt><strong>J</strong><span class="classifier">ndarray</span></dt><dd><p>a vector of currents to generate firing rates from</p>
</dd>
<dt><strong>state</strong><span class="classifier">dict of ndarrays</span></dt><dd><p>additional state needed by the step function</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.neurons.NeuronType">
<em class="property">class </em><code class="sig-prename descclassname">nengo.neurons.</code><code class="sig-name descname">NeuronType</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L45-L296"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for Nengo neuron models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>state</strong><span class="classifier">{str: Distribution}</span></dt><dd><p>State variables held by the neuron type during simulation.
Values in the dict indicate their initial values, or how
to obtain those initial values. These elements can also be
probed in the neuron population.</p>
</dd>
<dt><strong>negative</strong><span class="classifier">bool</span></dt><dd><p>Whether the neurons can emit negative outputs (i.e. negative spikes or rates).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.neurons.NeuronType.current">
<code class="sig-name descname">current</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L95-L130"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.current" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute current injected in each neuron given input, gain and bias.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> is assumed to be already projected onto the encoders
associated with the neurons and normalized to radius 1, so the maximum
expected current for a neuron occurs when input for that neuron is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n_samples,) or (n_samples, n_neurons) array_like</span></dt><dd><p>Scalar inputs for which to calculate current.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>current</strong><span class="classifier">(n_samples, n_neurons)</span></dt><dd><p>Current to be injected in each neuron.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.NeuronType.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L132-L197"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gain and bias needed to satisfy max_rates, intercepts.</p>
<p>This takes the neurons, approximates their response function, and then
uses that approximation to find the gain and bias value that will give
the requested intercepts and max_rates.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_rates</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>X-intercepts of neurons.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.NeuronType.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L210-L238"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max_rates and intercepts given gain and bias.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_rates</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>X-intercepts of neurons.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.NeuronType.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L240-L269"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute firing rates (in Hz) for given input <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This default implementation takes the naive approach of running the
step function for a second. This should suffice for most rate-based
neuron types; for spiking neurons it will likely fail (those models
should override this function).</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> is assumed to be already projected onto the encoders
associated with the neurons and normalized to radius 1, so the maximum
expected rate for a neuron occurs when input for that neuron is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n_samples,) or (n_samples, n_neurons) array_like</span></dt><dd><p>Scalar inputs for which to calculate rates.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rates</strong><span class="classifier">(n_samples, n_neurons) ndarray</span></dt><dd><p>The firing rates at each given value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.NeuronType.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L271-L289"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronType.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Simulation timestep.</p>
</dd>
<dt><strong>J</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Output activity associated with each neuron (e.g., spikes or firing rates).</p>
</dd>
<dt><strong>state</strong><span class="classifier">{str: array_like}</span></dt><dd><p>State variables associated with the population.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.neurons.NeuronTypeParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.neurons.</code><code class="sig-name descname">NeuronTypeParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L299-L305"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.NeuronTypeParam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="nengo.Direct">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Direct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L308-L335"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct" title="Permalink to this definition">¶</a></dt>
<dd><p>Signifies that an ensemble should simulate in direct mode.</p>
<p>In direct mode, the ensemble represents and transforms signals perfectly,
rather than through a neural approximation. Note that direct mode ensembles
with recurrent connections can easily diverge; most other neuron types will
instead saturate at a certain high firing rate.</p>
<dl class="py method">
<dt id="nengo.Direct.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L317-L319"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Direct.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L321-L323"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">None,</span> <span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Direct.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L325-L327"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Direct.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L329-L335"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Direct.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an error if called.</p>
<p>Rather than calling this function, the simulator will detect that
the ensemble is in direct mode, and bypass the neural approximation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.RectifiedLinear">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">RectifiedLinear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L338-L380"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified linear neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless it passes below zero, at which point
the neural activity will stay at zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.RectifiedLinear.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L364-L370"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine gain and bias by shifting and scaling the lines.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.RectifiedLinear.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L372-L376"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.RectifiedLinear.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L378-L380"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RectifiedLinear.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the rectification nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.SpikingRectifiedLinear">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">SpikingRectifiedLinear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L383-L418"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectified integrate and fire neuron model.</p>
<p>Each neuron is modeled as a rectified line. That is, the neuron’s activity
scales linearly with current, unless the current is less than zero, at
which point the neural activity will stay at zero. This is a spiking
version of the RectifiedLinear neuron model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.SpikingRectifiedLinear.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L404-L410"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Use RectifiedLinear to determine rates.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.SpikingRectifiedLinear.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">voltage</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L412-L418"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.SpikingRectifiedLinear.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the integrate and fire nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Sigmoid">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Sigmoid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_ref</span><span class="o">=</span><span class="default_value">0.0025</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L421-L474"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>A non-spiking neuron model whose response curve is a sigmoid.</p>
<p>Since the tuning curves are strictly positive, the <code class="docutils literal notranslate"><span class="pre">intercepts</span></code>
correspond to the inflection point of each sigmoid. That is,
<code class="docutils literal notranslate"><span class="pre">f(intercept)</span> <span class="pre">=</span> <span class="pre">0.5</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> is the pure sigmoid function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>The neuron refractory period, in seconds. The maximum firing rate of the
neurons is <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">tau_ref</span></code>. Must be positive (i.e. <code class="docutils literal notranslate"><span class="pre">tau_ref</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>).</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Sigmoid.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L446-L463"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Sigmoid.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L465-L470"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Sigmoid.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L472-L474"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sigmoid.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the sigmoid nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Tanh">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Tanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_ref</span><span class="o">=</span><span class="default_value">0.0025</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L477-L523"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>A non-spiking neuron model whose response curve is a hyperbolic tangent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>The neuron refractory period, in seconds. The maximum firing rate of the
neurons is <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">tau_ref</span></code>. Must be positive (i.e. <code class="docutils literal notranslate"><span class="pre">tau_ref</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>).</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Tanh.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L496-L513"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Tanh.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Tanh.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L515-L519"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Tanh.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Tanh.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L521-L523"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Tanh.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the tanh nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.LIFRate">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">LIFRate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_rc</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">tau_ref</span><span class="o">=</span><span class="default_value">0.002</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L526-L603"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.LIFRate.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L557-L574"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically determine gain, bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.LIFRate.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L576-L587"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of gain_bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.LIFRate.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L589-L595"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Always use LIFRate to determine rates.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.LIFRate.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L597-L603"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIFRate.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the LIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.LIF">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">LIF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_rc</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">tau_ref</span><span class="o">=</span><span class="default_value">0.002</span></em>, <em class="sig-param"><span class="n">min_voltage</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L608-L681"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Spiking version of the leaky integrate-and-fire (LIF) neuron model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>min_voltage</strong><span class="classifier">float</span></dt><dd><p>Minimum value for the membrane voltage. If <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>, the voltage
is never clipped.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.LIF.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">voltage</span></em>, <em class="sig-param"><span class="n">refractory_time</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L649-L681"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LIF.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the LIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.AdaptiveLIFRate">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">AdaptiveLIFRate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_n</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">inc_n</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">tau_rc</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">tau_ref</span><span class="o">=</span><span class="default_value">0.002</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L684-L749"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive non-spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal notranslate"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is incremented by <code class="docutils literal notranslate"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</dd>
<dt><strong>inc_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</dd>
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbd786dbfee9d-1"><span class="brackets">1</span></dt>
<dd><p>Camera, Giancarlo La, et al. “Minimal models of adapted neuronal
response to in Vivo-Like input currents.” Neural computation
16.10 (2004): 2101-2124.</p>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.AdaptiveLIFRate.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">adaptation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L745-L749"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIFRate.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIFRate nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.AdaptiveLIF">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">AdaptiveLIF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_n</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">inc_n</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">tau_rc</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">tau_ref</span><span class="o">=</span><span class="default_value">0.002</span></em>, <em class="sig-param"><span class="n">min_voltage</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L752-L827"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive spiking version of the LIF neuron model.</p>
<p>Works as the LIF model, except with adapation state <code class="docutils literal notranslate"><span class="pre">n</span></code>, which is
subtracted from the input current. Its dynamics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tau_n</span> <span class="n">dn</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">n</span></code> is incremented by <code class="docutils literal notranslate"><span class="pre">inc_n</span></code> when the neuron spikes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation time constant. Affects how quickly the adaptation state
decays to zero in the absence of spikes (larger = slower decay).</p>
</dd>
<dt><strong>inc_n</strong><span class="classifier">float</span></dt><dd><p>Adaptation increment. How much the adaptation state is increased after
each spike.</p>
</dd>
<dt><strong>tau_rc</strong><span class="classifier">float</span></dt><dd><p>Membrane RC time constant, in seconds. Affects how quickly the membrane
voltage decays to zero in the absence of input (larger = slower decay).</p>
</dd>
<dt><strong>tau_ref</strong><span class="classifier">float</span></dt><dd><p>Absolute refractory period, in seconds. This is how long the
membrane voltage is held at zero after a spike.</p>
</dd>
<dt><strong>min_voltage</strong><span class="classifier">float</span></dt><dd><p>Minimum value for the membrane voltage. If <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>, the voltage
is never clipped.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r01edae3c908d-1"><span class="brackets">1</span></dt>
<dd><p>Camera, Giancarlo La, et al. “Minimal models of adapted neuronal
response to in Vivo-Like input currents.” Neural computation
16.10 (2004): 2101-2124.</p>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.AdaptiveLIF.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">voltage</span></em>, <em class="sig-param"><span class="n">refractory_time</span></em>, <em class="sig-param"><span class="n">adaptation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L823-L827"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.AdaptiveLIF.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the AdaptiveLIF nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Izhikevich">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Izhikevich</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau_recovery</span><span class="o">=</span><span class="default_value">0.02</span></em>, <em class="sig-param"><span class="n">coupling</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">reset_voltage</span><span class="o">=</span><span class="default_value">- 65.0</span></em>, <em class="sig-param"><span class="n">reset_recovery</span><span class="o">=</span><span class="default_value">8.0</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L830-L935"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich" title="Permalink to this definition">¶</a></dt>
<dd><p>Izhikevich neuron model.</p>
<p>This implementation is based on the original paper <a class="reference internal" href="#re5df505b8668-1" id="id12">[1]</a>;
however, we rename some variables for clarity.
What was originally ‘v’ we term ‘voltage’, which represents the membrane
potential of each neuron. What was originally ‘u’ we term ‘recovery’,
which represents membrane recovery, “which accounts for the activation
of K+ ionic currents and inactivation of Na+ ionic currents.”
The ‘a’, ‘b’, ‘c’, and ‘d’ parameters are also renamed
(see the parameters below).</p>
<p>We use default values that correspond to regular spiking (‘RS’) neurons.
For other classes of neurons, set the parameters as follows.</p>
<ul class="simple">
<li><p>Intrinsically bursting (IB): <code class="docutils literal notranslate"><span class="pre">reset_voltage=-55,</span> <span class="pre">reset_recovery=4</span></code></p></li>
<li><p>Chattering (CH): <code class="docutils literal notranslate"><span class="pre">reset_voltage=-50,</span> <span class="pre">reset_recovery=2</span></code></p></li>
<li><p>Fast spiking (FS): <code class="docutils literal notranslate"><span class="pre">tau_recovery=0.1</span></code></p></li>
<li><p>Low-threshold spiking (LTS): <code class="docutils literal notranslate"><span class="pre">coupling=0.25</span></code></p></li>
<li><p>Resonator (RZ): <code class="docutils literal notranslate"><span class="pre">tau_recovery=0.1,</span> <span class="pre">coupling=0.26</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau_recovery</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘a’) Time scale of the recovery variable.</p>
</dd>
<dt><strong>coupling</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘b’) How sensitive recovery is to subthreshold
fluctuations of voltage.</p>
</dd>
<dt><strong>reset_voltage</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘c’) The voltage to reset to after a spike, in millivolts.</p>
</dd>
<dt><strong>reset_recovery</strong><span class="classifier">float, optional</span></dt><dd><p>(Originally ‘d’) The recovery value to reset to after a spike.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re5df505b8668-1"><span class="brackets"><a class="fn-backref" href="#id12">1</a></span></dt>
<dd><p>E. M. Izhikevich, “Simple model of spiking neurons.”
IEEE Transactions on Neural Networks, vol. 14, no. 6, pp. 1569-1572.
(<a class="reference external" href="http://www.izhikevich.org/publications/spikes.pdf">http://www.izhikevich.org/publications/spikes.pdf</a>)</p>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Izhikevich.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L899-L912"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates steady-state firing rate given gain and bias.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.Izhikevich.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">voltage</span></em>, <em class="sig-param"><span class="n">recovery</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L914-L935"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Izhikevich.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the Izhikevich nonlinearity.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.neurons.RatesToSpikesNeuronType">
<em class="property">class </em><code class="sig-prename descclassname">nengo.neurons.</code><code class="sig-name descname">RatesToSpikesNeuronType</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base_type</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L938-L982"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.RatesToSpikesNeuronType" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for neuron types that turn rate types into spiking ones.</p>
<dl class="py method">
<dt id="nengo.neurons.RatesToSpikesNeuronType.gain_bias">
<code class="sig-name descname">gain_bias</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_rates</span></em>, <em class="sig-param"><span class="n">intercepts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L968-L969"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.RatesToSpikesNeuronType.gain_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gain and bias needed to satisfy max_rates, intercepts.</p>
<p>This takes the neurons, approximates their response function, and then
uses that approximation to find the gain and bias value that will give
the requested intercepts and max_rates.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>max_rates</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>X-intercepts of neurons.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.RatesToSpikesNeuronType.max_rates_intercepts">
<code class="sig-name descname">max_rates_intercepts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L971-L972"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.RatesToSpikesNeuronType.max_rates_intercepts" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max_rates and intercepts given gain and bias.</p>
<p>Note that this default implementation is very slow! Whenever possible,
subclasses should override this with a neuron-specific implementation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gain associated with each neuron. Sometimes denoted alpha.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>max_rates</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Maximum firing rates of neurons.</p>
</dd>
<dt><strong>intercepts</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>X-intercepts of neurons.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.RatesToSpikesNeuronType.rates">
<code class="sig-name descname">rates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">gain</span></em>, <em class="sig-param"><span class="n">bias</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L974-L975"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.RatesToSpikesNeuronType.rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute firing rates (in Hz) for given input <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>This default implementation takes the naive approach of running the
step function for a second. This should suffice for most rate-based
neuron types; for spiking neurons it will likely fail (those models
should override this function).</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">x</span></code> is assumed to be already projected onto the encoders
associated with the neurons and normalized to radius 1, so the maximum
expected rate for a neuron occurs when input for that neuron is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n_samples,) or (n_samples, n_neurons) array_like</span></dt><dd><p>Scalar inputs for which to calculate rates.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Gains associated with each neuron.</p>
</dd>
<dt><strong>bias</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Bias current associated with each neuron.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rates</strong><span class="classifier">(n_samples, n_neurons) ndarray</span></dt><dd><p>The firing rates at each given value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.neurons.RatesToSpikesNeuronType.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L977-L978"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.neurons.RatesToSpikesNeuronType.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Simulation timestep.</p>
</dd>
<dt><strong>J</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Output activity associated with each neuron (e.g., spikes or firing rates).</p>
</dd>
<dt><strong>state</strong><span class="classifier">{str: array_like}</span></dt><dd><p>State variables associated with the population.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.RegularSpiking">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">RegularSpiking</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base_type</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L985-L1015"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RegularSpiking" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a rate neuron type into a spiking one with regular inter-spike intervals.</p>
<p>Spikes at regular intervals based on the rates of the base neuron type. <a class="reference internal" href="#ra963c4138a3a-1" id="id14">[1]</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base_type</strong><span class="classifier">NeuronType</span></dt><dd><p>A rate-based neuron type to convert to a regularly spiking neuron.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra963c4138a3a-1"><span class="brackets"><a class="fn-backref" href="#id14">1</a></span></dt>
<dd><p>Voelker, A. R., Rasmussen, D., &amp; Eliasmith, C. (2020). A Spike in
Performance: Training Hybrid-Spiking Neural Networks with Quantized Activation
Functions. arXiv preprint arXiv:2002.03553. (https://arxiv.org/abs/2002.03553)</p>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.RegularSpiking.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">voltage</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L1010-L1015"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.RegularSpiking.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Simulation timestep.</p>
</dd>
<dt><strong>J</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Output activity associated with each neuron (e.g., spikes or firing rates).</p>
</dd>
<dt><strong>state</strong><span class="classifier">{str: array_like}</span></dt><dd><p>State variables associated with the population.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.StochasticSpiking">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">StochasticSpiking</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base_type</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L1018-L1056"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.StochasticSpiking" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a rate neuron type into a spiking one using stochastic rounding.</p>
<p>The expected number of spikes per timestep <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">dt</span> <span class="pre">*</span> <span class="pre">r</span></code> is determined by the
base type firing rate <code class="docutils literal notranslate"><span class="pre">r</span></code> and the timestep <code class="docutils literal notranslate"><span class="pre">dt</span></code>. Given the fractional part <code class="docutils literal notranslate"><span class="pre">f</span></code>
and integer part <code class="docutils literal notranslate"><span class="pre">q</span></code> of <code class="docutils literal notranslate"><span class="pre">e</span></code>, the number of generated spikes is <code class="docutils literal notranslate"><span class="pre">q</span></code> with
probability <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">+</span> <span class="pre">1</span></code> with probability <code class="docutils literal notranslate"><span class="pre">f</span></code>. For <code class="docutils literal notranslate"><span class="pre">e</span></code> much less than
one, this is very similar to Poisson statistics.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base_type</strong><span class="classifier">NeuronType</span></dt><dd><p>A rate-based neuron type to convert to a Poisson spiking neuron.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.StochasticSpiking.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">base_state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L1044-L1056"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.StochasticSpiking.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Simulation timestep.</p>
</dd>
<dt><strong>J</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Output activity associated with each neuron (e.g., spikes or firing rates).</p>
</dd>
<dt><strong>state</strong><span class="classifier">{str: array_like}</span></dt><dd><p>State variables associated with the population.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.PoissonSpiking">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">PoissonSpiking</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base_type</span></em>, <em class="sig-param"><span class="n">amplitude</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">initial_state</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L1059-L1090"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.PoissonSpiking" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a rate neuron type into a spiking one with Poisson spiking statistics.</p>
<p>Spikes with Poisson probability based on the rates of the base neuron type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>base_type</strong><span class="classifier">NeuronType</span></dt><dd><p>A rate-based neuron type to convert to a Poisson spiking neuron.</p>
</dd>
<dt><strong>amplitude</strong><span class="classifier">float</span></dt><dd><p>Scaling factor on the neuron output. Corresponds to the relative
amplitude of the output spikes of the neuron.</p>
</dd>
<dt><strong>initial_state</strong><span class="classifier">{str: Distribution or array_like}</span></dt><dd><p>Mapping from state variables names to their desired initial value.
These values will override the defaults set in the class’s state attribute.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.PoissonSpiking.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">output</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">base_state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/neurons.py#L1081-L1090"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.PoissonSpiking.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the differential equation for this neuron type.</p>
<p>At a minimum, NeuronType subclasses must implement this method.
That implementation should modify the <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter rather
than returning anything, for efficiency reasons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>Simulation timestep.</p>
</dd>
<dt><strong>J</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Input currents associated with each neuron.</p>
</dd>
<dt><strong>output</strong><span class="classifier">(n_neurons,) array_like</span></dt><dd><p>Output activity associated with each neuron (e.g., spikes or firing rates).</p>
</dd>
<dt><strong>state</strong><span class="classifier">{str: array_like}</span></dt><dd><p>State variables associated with the population.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nengo.processes">
<span id="processes"></span><h2>Processes<a class="headerlink" href="#module-nengo.processes" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Process</span></code></a></p></td>
<td><p>A general system with input, output, and state.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.processes.WhiteNoise" title="nengo.processes.WhiteNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.WhiteNoise</span></code></a></p></td>
<td><p>Full-spectrum white noise process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.processes.FilteredNoise" title="nengo.processes.FilteredNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.FilteredNoise</span></code></a></p></td>
<td><p>Filtered white noise process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.processes.BrownNoise" title="nengo.processes.BrownNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.BrownNoise</span></code></a></p></td>
<td><p>Brown noise process (aka Brownian noise, red noise, Wiener process).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.processes.WhiteSignal" title="nengo.processes.WhiteSignal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.WhiteSignal</span></code></a></p></td>
<td><p>An ideal low-pass filtered white noise process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.processes.PresentInput" title="nengo.processes.PresentInput"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.PresentInput</span></code></a></p></td>
<td><p>Present a series of inputs, each for the same fixed length of time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.processes.Piecewise" title="nengo.processes.Piecewise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.processes.Piecewise</span></code></a></p></td>
<td><p>A piecewise function with different options for interpolation.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.processes.WhiteNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">WhiteNoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span><span class="o">=</span><span class="default_value">Gaussian(mean=0, std=1)</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L13-L56"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Full-spectrum white noise process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">Distribution, optional</span></dt><dd><p>The distribution from which to draw samples.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to scale the white noise for integration. Integrating white
noise requires using a time constant of <code class="docutils literal notranslate"><span class="pre">sqrt(dt)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">dt</span></code>
on the noise term <a class="reference internal" href="#rd2dd8a36bd47-1" id="id16">[1]</a>, to ensure the magnitude of the integrated
noise does not change with <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd2dd8a36bd47-1"><span class="brackets"><a class="fn-backref" href="#id16">1</a></span></dt>
<dd><p>Gillespie, D.T. (1996) Exact numerical simulation of the Ornstein-
Uhlenbeck process and its integral. Phys. Rev. E 54, pp. 2084-91.</p>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.processes.WhiteNoise.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L42-L56"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteNoise.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.processes.FilteredNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">FilteredNoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">synapse</span><span class="o">=</span><span class="default_value">Lowpass(tau=0.005)</span></em>, <em class="sig-param"><span class="n">dist</span><span class="o">=</span><span class="default_value">Gaussian(mean=0, std=1)</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L59-L111"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Filtered white noise process.</p>
<p>This process takes white noise and filters it using the provided synapse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>synapse</strong><span class="classifier">Synapse, optional</span></dt><dd><p>The synapse to use to filter the noise.</p>
</dd>
<dt><strong>dist</strong><span class="classifier">Distribution, optional</span></dt><dd><p>The distribution used to generate the white noise.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to scale the white noise for integration, making the output
signal invariant to <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.processes.FilteredNoise.make_state">
<code class="sig-name descname">make_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L93-L94"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise.make_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of signals to represent the state of this process.</p>
<p>The builder uses this to allocate memory for the process state, so
that the state can be represented as part of the whole simulator state.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a></span></dt><dd><p>The data type requested by the builder. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, then this
function is free to choose the best type for the signals involved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>initial_state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to arrays containing the initial state
values. The keys will be used to identify the signals in
<a class="reference internal" href="#nengo.Process.make_step" title="nengo.Process.make_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_step</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.processes.FilteredNoise.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L96-L111"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.FilteredNoise.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.processes.BrownNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">BrownNoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dist</span><span class="o">=</span><span class="default_value">Gaussian(mean=0, std=1)</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L114-L130"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.BrownNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Brown noise process (aka Brownian noise, red noise, Wiener process).</p>
<p>This process is the integral of white noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dist</strong><span class="classifier">Distribution, optional</span></dt><dd><p>The distribution used to generate the white noise.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.processes.WhiteSignal">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">WhiteSignal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">period</span></em>, <em class="sig-param"><span class="n">high</span></em>, <em class="sig-param"><span class="n">rms</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L133-L222"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteSignal" title="Permalink to this definition">¶</a></dt>
<dd><p>An ideal low-pass filtered white noise process.</p>
<p>This signal is created in the frequency domain, and designed to have
exactly equal power at all frequencies below the cut-off frequency,
and no power above the cut-off.</p>
<p>The signal is naturally periodic, so it can be used beyond its period
while still being continuous with continuous derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>period</strong><span class="classifier">float</span></dt><dd><p>A white noise signal with this period will be generated.
Samples will repeat after this duration.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float</span></dt><dd><p>The cut-off frequency of the low-pass filter, in Hz.
Must not exceed the Nyquist frequency for the simulation
timestep, which is <code class="docutils literal notranslate"><span class="pre">0.5</span> <span class="pre">/</span> <span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>rms</strong><span class="classifier">float, optional</span></dt><dd><p>The root mean square power of the filtered signal</p>
</dd>
<dt><strong>y0</strong><span class="classifier">float, optional</span></dt><dd><p>Align the phase of each output dimension to begin at the value
that is closest (in absolute value) to y0.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures noise will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.processes.WhiteSignal.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L180-L222"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.WhiteSignal.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.processes.PresentInput">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">PresentInput</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inputs</span></em>, <em class="sig-param"><span class="n">presentation_time</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L225-L258"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PresentInput" title="Permalink to this definition">¶</a></dt>
<dd><p>Present a series of inputs, each for the same fixed length of time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inputs</strong><span class="classifier">array_like</span></dt><dd><p>Inputs to present, where each row is an input. Rows will be flattened.</p>
</dd>
<dt><strong>presentation_time</strong><span class="classifier">float</span></dt><dd><p>Show each input for this amount of time (in seconds).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.processes.PresentInput.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L246-L258"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PresentInput.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.processes.PiecewiseDataParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">PiecewiseDataParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L261-L313"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PiecewiseDataParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Piecewise-specific validation for the data dictionary.</p>
<p>In the <a class="reference internal" href="#nengo.processes.Piecewise" title="nengo.processes.Piecewise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Piecewise</span></code></a> data dict, the keys are points in time (float) and
values are numerical constants or callables of the same dimensionality.</p>
<dl class="py method">
<dt id="nengo.processes.PiecewiseDataParam.hashvalue">
<code class="sig-name descname">hashvalue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">instance</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L310-L313"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.PiecewiseDataParam.hashvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a hashable value (<a class="reference external" href="https://docs.python.org/3/library/functions.html#hash" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash</span></code></a> can be called on the output).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.processes.Piecewise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.processes.</code><code class="sig-name descname">Piecewise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'zero'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L316-L482"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.Piecewise" title="Permalink to this definition">¶</a></dt>
<dd><p>A piecewise function with different options for interpolation.</p>
<p>Given an input dictionary of <code class="docutils literal notranslate"><span class="pre">{0:</span> <span class="pre">0,</span> <span class="pre">0.5:</span> <span class="pre">-1,</span> <span class="pre">0.75:</span> <span class="pre">0.5,</span> <span class="pre">1:</span> <span class="pre">0}</span></code>,
this process  will emit the numerical values (0, -1, 0.5, 0)
starting at the corresponding time points (0, 0.5, 0.75, 1).</p>
<p>The keys in the input dictionary must be times (float or int).
The values in the dictionary can be floats, lists of floats,
or numpy arrays. All lists or numpy arrays must be of the same length,
as the output shape of the process will be determined by the shape
of the values.</p>
<p>Interpolation on the data points using <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a> is also
supported. The default interpolation is ‘zero’, which creates a
piecewise function whose values change at the specified time points.
So the above example would be shortcut for:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.75</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>For times before the first specified time, an array of zeros (of
the correct length) will be emitted.
This means that the above can be simplified to:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nengo.processes</span> <span class="kn">import</span> <span class="n">Piecewise</span>

<span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary mapping times to the values that should be emitted
at those times. Times must be numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str, optional</span></dt><dd><p>One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values begin at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nengo.processes</span> <span class="kn">import</span> <span class="n">Piecewise</span>
<span class="n">process</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">({</span><span class="mf">0.5</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">()</span> <span class="k">as</span> <span class="n">model</span><span class="p">:</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">size_out</span><span class="o">=</span><span class="n">process</span><span class="o">.</span><span class="n">default_size_out</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Probe</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Simulator</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">sim</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">up</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">trange</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">t</span> <span class="o">==</span> <span class="mf">0.58</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[[ 0.]]
[[ 1.]]
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary mapping times to the values that should be emitted
at those times. Times are numbers (ints or floats), while values
can be numbers, lists of numbers, numpy arrays of numbers,
or callables that return any of those options.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str</span></dt><dd><p>One of ‘linear’, ‘nearest’, ‘slinear’, ‘quadratic’, ‘cubic’, or ‘zero’.
Specifies how to interpolate between times with specified value.
‘zero’ creates a plain piecewise function whose values change at
corresponding time points, while all other options interpolate
as described in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.processes.Piecewise.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/processes.py#L449-L482"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.processes.Piecewise.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Process">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Process</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default_size_in</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">default_size_out</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">default_dt</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L241-L460"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>A general system with input, output, and state.</p>
<p>For more details on how to use processes and make
custom process subclasses, see <a class="reference internal" href="examples/advanced/processes.html"><span class="doc">Processes and how to use them</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default_size_in</strong><span class="classifier">int</span></dt><dd><p>Sets the default size in for nodes using this process.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>Sets the default size out for nodes running this process. Also,
if <code class="docutils literal notranslate"><span class="pre">d</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</dd>
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trange</span></code></a>, this will be used.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">dt</span></code> is not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>, <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
<a class="reference internal" href="#nengo.Process.ntrange" title="nengo.Process.ntrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ntrange</span></code></a>, or <a class="reference internal" href="#nengo.Process.trange" title="nengo.Process.trange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trange</span></code></a>, this will be used.</p>
</dd>
<dt><strong>default_size_in</strong><span class="classifier">int</span></dt><dd><p>The default size in for nodes using this process.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>The default size out for nodes running this process. Also, if <code class="docutils literal notranslate"><span class="pre">d</span></code> is
not specified in <a class="reference internal" href="#nengo.Process.run" title="nengo.Process.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a> or <a class="reference internal" href="#nengo.Process.run_steps" title="nengo.Process.run_steps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_steps</span></code></a>,
this will be used.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int or None</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Process.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L290-L319"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process on a given input.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal notranslate"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">ndarray</span></dt><dd><p>The input signal given to the process.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int, optional</span></dt><dd><p>Output dimensionality. If None, <code class="docutils literal notranslate"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator used for stochstic processes.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, a new output array will be created for output.
If False, the input signal <code class="docutils literal notranslate"><span class="pre">x</span></code> will be overwritten.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.get_rng">
<code class="sig-name descname">get_rng</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rng</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L321-L330"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.get_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a properly seeded independent RNG for the process step.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>The parent random number generator to use if the seed is not set.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.make_state">
<code class="sig-name descname">make_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L332-L359"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.make_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of signals to represent the state of this process.</p>
<p>The builder uses this to allocate memory for the process state, so
that the state can be represented as part of the whole simulator state.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a></span></dt><dd><p>The data type requested by the builder. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, then this
function is free to choose the best type for the signals involved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>initial_state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to arrays containing the initial state
values. The keys will be used to identify the signals in
<a class="reference internal" href="#nengo.Process.make_step" title="nengo.Process.make_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_step</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L361-L384"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L386-L405"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given length of time.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal notranslate"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The length of time to run.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int, optional</span></dt><dd><p>Output dimensionality. If None, <code class="docutils literal notranslate"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator used for stochstic processes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.run_steps">
<code class="sig-name descname">run_steps</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n_steps</span></em>, <em class="sig-param"><span class="n">d</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L407-L433"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.run_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process without input for given number of steps.</p>
<p>Keyword arguments that do not appear in the parameter list below
will be passed to the <code class="docutils literal notranslate"><span class="pre">make_step</span></code> function of this process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_steps</strong><span class="classifier">int</span></dt><dd><p>The number of steps to run.</p>
</dd>
<dt><strong>d</strong><span class="classifier">int, optional</span></dt><dd><p>Output dimensionality. If None, <code class="docutils literal notranslate"><span class="pre">default_size_out</span></code> will be used.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator used for stochstic processes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.ntrange">
<code class="sig-name descname">ntrange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_steps</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L435-L446"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.ntrange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given number of steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_steps</strong><span class="classifier">int</span></dt><dd><p>The given number of steps.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.Process.trange">
<code class="sig-name descname">trange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/base.py#L448-L460"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Process.trange" title="Permalink to this definition">¶</a></dt>
<dd><p>Create time points corresponding to a given length of time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The given length of time.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>Simulation timestep. If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nengo.solvers">
<span id="solvers"></span><h2>Solvers<a class="headerlink" href="#module-nengo.solvers" title="Permalink to this headline">¶</a></h2>
<p>Classes concerned with solving for decoders or full weight matrices.</p>
<div class="graphviz"><img src="_images/inheritance-47436b5f83567651f4c8f6967a4351f2ed9adcfd.png" alt="Inheritance diagram of nengo.solvers" usemap="#inheritance3f3e18a10f" class="inheritance graphviz" /></div>
<map id="inheritance3f3e18a10f" name="inheritance3f3e18a10f">
<area shape="rect" id="node1" href="#nengo.solvers.Lstsq" target="_top" title="Unregularized least&#45;squares solver." alt="" coords="166,5,238,31"/>
<area shape="rect" id="node2" href="#nengo.solvers.Solver" target="_top" title="Decoder or weight solver." alt="" coords="21,153,93,179"/>
<area shape="rect" id="node3" href="#nengo.solvers.LstsqDrop" target="_top" title="Find sparser decoders/weights by dropping small values." alt="" coords="159,55,245,80"/>
<area shape="rect" id="node4" href="#nengo.solvers.LstsqL1" target="_top" title="Least&#45;squares solver with L1 and L2 regularization (elastic net)." alt="" coords="166,104,238,129"/>
<area shape="rect" id="node5" href="#nengo.solvers.LstsqL2" target="_top" title="Least&#45;squares solver with L2 regularization." alt="" coords="166,153,238,179"/>
<area shape="rect" id="node8" href="#nengo.solvers.LstsqNoise" target="_top" title="Least&#45;squares solver with additive Gaussian white noise." alt="" coords="156,203,248,228"/>
<area shape="rect" id="node9" href="#nengo.solvers.Nnls" target="_top" title="Non&#45;negative least&#45;squares solver without regularization." alt="" coords="166,252,238,277"/>
<area shape="rect" id="node12" href="#nengo.solvers.NoSolver" target="_top" title="Manually pass in weights, bypassing the decoder solver." alt="" coords="162,301,242,327"/>
<area shape="rect" id="node6" href="#nengo.solvers.LstsqL2nz" target="_top" title="Least&#45;squares solver with L2 regularization on non&#45;zero components." alt="" coords="312,153,399,179"/>
<area shape="rect" id="node7" href="#nengo.solvers.LstsqMultNoise" target="_top" title="Least&#45;squares solver with multiplicative white noise." alt="" coords="296,203,415,228"/>
<area shape="rect" id="node10" href="#nengo.solvers.NnlsL2" target="_top" title="Non&#45;negative least&#45;squares solver with L2 regularization." alt="" coords="319,252,391,277"/>
<area shape="rect" id="node11" href="#nengo.solvers.NnlsL2nz" target="_top" title="Non&#45;negative least&#45;squares with L2 regularization on nonzero components." alt="" coords="463,252,543,277"/>
<area shape="rect" id="node13" href="#nengo.solvers.SolverParam" target="_top" title="A parameter in which the value is a `.Solver` instance." alt="" coords="5,104,108,129"/>
</map><table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.Solver</span></code></a></p></td>
<td><p>Decoder or weight solver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.Lstsq</span></code></a></p></td>
<td><p>Unregularized least-squares solver.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.LstsqNoise" title="nengo.solvers.LstsqNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqNoise</span></code></a></p></td>
<td><p>Least-squares solver with additive Gaussian white noise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.LstsqMultNoise" title="nengo.solvers.LstsqMultNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqMultNoise</span></code></a></p></td>
<td><p>Least-squares solver with multiplicative white noise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL2</span></code></a></p></td>
<td><p>Least-squares solver with L2 regularization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL2nz</span></code></a></p></td>
<td><p>Least-squares solver with L2 regularization on non-zero components.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.LstsqL1" title="nengo.solvers.LstsqL1"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqL1</span></code></a></p></td>
<td><p>Least-squares solver with L1 and L2 regularization (elastic net).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.LstsqDrop" title="nengo.solvers.LstsqDrop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.LstsqDrop</span></code></a></p></td>
<td><p>Find sparser decoders/weights by dropping small values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.Nnls" title="nengo.solvers.Nnls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.Nnls</span></code></a></p></td>
<td><p>Non-negative least-squares solver without regularization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.NnlsL2" title="nengo.solvers.NnlsL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.NnlsL2</span></code></a></p></td>
<td><p>Non-negative least-squares solver with L2 regularization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.solvers.NnlsL2nz" title="nengo.solvers.NnlsL2nz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.NnlsL2nz</span></code></a></p></td>
<td><p>Non-negative least-squares with L2 regularization on nonzero components.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.solvers.NoSolver" title="nengo.solvers.NoSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.solvers.NoSolver</span></code></a></p></td>
<td><p>Manually pass in weights, bypassing the decoder solver.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.solvers.Solver">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">Solver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L22-L84"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Decoder or weight solver.</p>
<p>A solver can have the <code class="docutils literal notranslate"><span class="pre">weights</span></code> parameter equal to <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Weight solvers are used to form neuron-to-neuron weight matrices.
They can be compositional or non-compositional. Non-compositional
solvers must operate on the whole neuron-to-neuron weight matrix
(i.e., each target is a separate postsynaptic current, without the bias
term), while compositional solvers operate in the decoded state-space
(i.e., each target is a dimension in state-space). Compositional solvers
then combine the returned <code class="docutils literal notranslate"><span class="pre">X</span></code> with the transform and/or encoders to
generate the full weight matrix.</p>
<p>For a solver to be compositional, the following property must be true:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>  <span class="k">if</span> <span class="ow">and</span> <span class="n">only</span> <span class="k">if</span>  <span class="n">L</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">L</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L</span></code> is some arbitrary linear operator (i.e., the transform and/or
encoders for the postsynaptic population). This property can then be
leveraged by the backend for efficiency. See the solver’s
<code class="docutils literal notranslate"><span class="pre">compositional</span></code> class attribute to determine if it is compositional.</p>
<p>Non-weight solvers always operate in the decoded state-space regardless of
whether they are compositional or non-compositional.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.SolverParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">SolverParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L87-L92"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.SolverParam" title="Permalink to this definition">¶</a></dt>
<dd><p>A parameter in which the value is a <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a> instance.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.Lstsq">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">Lstsq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">rcond</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L95-L132"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Lstsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregularized least-squares solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>rcond</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off ratio for small singular values (see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rcond</strong><span class="classifier">float</span></dt><dd><p>Cut-off ratio for small singular values (see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg.lstsq</span></code></a>).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.LstsqNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqNoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">noise</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">Cholesky()</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L160-L177"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with additive Gaussian white noise.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>noise</strong><span class="classifier">float</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.LstsqMultNoise">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqMultNoise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">noise</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">Cholesky()</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L181-L189"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqMultNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with multiplicative white noise.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>noise</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>noise</strong><span class="classifier">float</span></dt><dd><p>Amount of noise, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.LstsqL2">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqL2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">Cholesky()</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L217-L233"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.LstsqL2nz">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqL2nz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">solver</span><span class="o">=</span><span class="default_value">Cholesky()</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L237-L253"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L2 regularization on non-zero components.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a>, optional</span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl>
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>solver</strong><span class="classifier"><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LeastSquaresSolver</span></code></a></span></dt><dd><p>Subsolver to use for solving the least squares problem.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.LstsqL1">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqL1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">l1</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">l2</span><span class="o">=</span><span class="default_value">1e-06</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">1000</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L256-L326"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqL1" title="Permalink to this definition">¶</a></dt>
<dd><p>Least-squares solver with L1 and L2 regularization (elastic net).</p>
<p>This method is well suited for creating sparse decoders or weight matrices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires <a class="reference external" href="https://scikit-learn.org/stable/">scikit-learn</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>l1</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of L1 regularization.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of L2 regularization.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations for the underlying elastic net.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>l1</strong><span class="classifier">float</span></dt><dd><p>Amount of L1 regularization.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">float</span></dt><dd><p>Amount of L2 regularization.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations for the underlying elastic net.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.LstsqDrop">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">LstsqDrop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">0.25</span></em>, <em class="sig-param"><span class="n">solver1</span><span class="o">=</span><span class="default_value">LstsqL2(reg=0.001)</span></em>, <em class="sig-param"><span class="n">solver2</span><span class="o">=</span><span class="default_value">LstsqL2()</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L329-L399"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.LstsqDrop" title="Permalink to this definition">¶</a></dt>
<dd><p>Find sparser decoders/weights by dropping small values.</p>
<p>This solver first solves for coefficients (decoders/weights) with
L2 regularization, drops those nearest to zero, and retrains remaining.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>drop</strong><span class="classifier">float, optional</span></dt><dd><p>Fraction of decoders or weights to set to zero.</p>
</dd>
<dt><strong>solver1</strong><span class="classifier">Solver, optional</span></dt><dd><p>Solver for finding the initial decoders.</p>
</dd>
<dt><strong>solver2</strong><span class="classifier">Solver, optional</span></dt><dd><p>Used for re-solving for the decoders after dropout.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>drop</strong><span class="classifier">float</span></dt><dd><p>Fraction of decoders or weights to set to zero.</p>
</dd>
<dt><strong>solver1</strong><span class="classifier">Solver</span></dt><dd><p>Solver for finding the initial decoders.</p>
</dd>
<dt><strong>solver2</strong><span class="classifier">Solver</span></dt><dd><p>Used for re-solving for the decoders after dropout.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.Nnls">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">Nnls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L437-L470"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.Nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver without regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.Lstsq" title="nengo.solvers.Lstsq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lstsq</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.NnlsL2">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">NnlsL2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">0.1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L474-L513"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares solver with L2 regularization.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2" title="nengo.solvers.LstsqL2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LstsqL2</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.NnlsL2nz">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">NnlsL2nz</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">reg</span><span class="o">=</span><span class="default_value">0.1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L517-L530"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NnlsL2nz" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-negative least-squares with L2 regularization on nonzero components.</p>
<p>Similar to <a class="reference internal" href="#nengo.solvers.LstsqL2nz" title="nengo.solvers.LstsqL2nz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LstsqL2nz</span></code></a>, except the output values are non-negative.</p>
<p>If solving for non-negative <strong>weights</strong>, it is important that the
intercepts of the post-population are also non-negative, since neurons with
negative intercepts will never be silent, affecting output accuracy.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/">SciPy</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
<dt><strong>reg</strong><span class="classifier">float, optional</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reg</strong><span class="classifier">float</span></dt><dd><p>Amount of regularization, as a fraction of the neuron activity.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool</span></dt><dd><p>If False, solve for decoders. If True, solve for weights.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.solvers.NoSolver">
<em class="property">class </em><code class="sig-prename descclassname">nengo.solvers.</code><code class="sig-name descname">NoSolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/solvers.py#L533-L579"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.solvers.NoSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually pass in weights, bypassing the decoder solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">(n_neurons, size_out) array_like, optional</span></dt><dd><p>The array of decoders to use.
<code class="docutils literal notranslate"><span class="pre">size_out</span></code> is the dimensionality of the decoded signal (determined
by the connection function).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, connection will use factored weights (decoders from this
solver, transform, and encoders).
If True, connection will use a full weight matrix (created by
linearly combining decoder, transform, and encoders).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>values</strong><span class="classifier">(n_neurons, size_out) array_like, optional</span></dt><dd><p>The array of decoders to use.
<code class="docutils literal notranslate"><span class="pre">size_out</span></code> is the dimensionality of the decoded signal (determined
by the connection function).
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, which is the default, the solver will return an
appropriately sized array of zeros.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, connection will use factored weights (decoders from this
solver, transform, and encoders).
If True, connection will use a full weight matrix (created by
linearly combining decoder, transform, and encoders).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="module-nengo.utils.least_squares_solvers">
<span id="solver-methods"></span><h3>Solver methods<a class="headerlink" href="#module-nengo.utils.least_squares_solvers" title="Permalink to this headline">¶</a></h3>
<p>These solvers are to be passed as arguments to <a class="reference internal" href="#nengo.solvers.Solver" title="nengo.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a> objects.</p>
<p>For example:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">nengo.solvers</span> <span class="kn">import</span> <span class="n">LstsqL2</span>
<span class="kn">from</span> <span class="nn">nengo.utils.least_squares_solvers</span> <span class="kn">import</span> <span class="n">SVD</span>

<span class="k">with</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Network</span><span class="p">():</span>
    <span class="n">ens_a</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ens_b</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">Ensemble</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nengo</span><span class="o">.</span><span class="n">Connection</span><span class="p">(</span><span class="n">ens_a</span><span class="p">,</span> <span class="n">ens_b</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">LstsqL2</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">SVD</span><span class="p">()))</span>
</pre></div>
</div>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.format_system" title="nengo.utils.least_squares_solvers.format_system"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.format_system</span></code></a></p></td>
<td><p>Extract data from A/Y matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.rmses" title="nengo.utils.least_squares_solvers.rmses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.rmses</span></code></a></p></td>
<td><p>Returns the root-mean-squared error (RMSE) of the solution X.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="nengo.utils.least_squares_solvers.LeastSquaresSolver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.LeastSquaresSolver</span></code></a></p></td>
<td><p>Linear least squares system solver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.Cholesky" title="nengo.utils.least_squares_solvers.Cholesky"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.Cholesky</span></code></a></p></td>
<td><p>Solve a least-squares system using the Cholesky decomposition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.ConjgradScipy" title="nengo.utils.least_squares_solvers.ConjgradScipy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.ConjgradScipy</span></code></a></p></td>
<td><p>Solve a least-squares system using Scipy’s conjugate gradient.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.LSMRScipy" title="nengo.utils.least_squares_solvers.LSMRScipy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.LSMRScipy</span></code></a></p></td>
<td><p>Solve a least-squares system using Scipy’s LSMR.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.Conjgrad" title="nengo.utils.least_squares_solvers.Conjgrad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.Conjgrad</span></code></a></p></td>
<td><p>Solve a least-squares system using conjugate gradient.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.BlockConjgrad" title="nengo.utils.least_squares_solvers.BlockConjgrad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.BlockConjgrad</span></code></a></p></td>
<td><p>Solve a multiple-RHS least-squares system using block conj.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.SVD" title="nengo.utils.least_squares_solvers.SVD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.SVD</span></code></a></p></td>
<td><p>Solve a least-squares system using full SVD.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.RandomizedSVD" title="nengo.utils.least_squares_solvers.RandomizedSVD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.RandomizedSVD</span></code></a></p></td>
<td><p>Solve a least-squares system using a randomized (partial) SVD.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.utils.least_squares_solvers.LeastSquaresSolverParam" title="nengo.utils.least_squares_solvers.LeastSquaresSolverParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.utils.least_squares_solvers.LeastSquaresSolverParam</span></code></a></p></td>
<td><p>A parameter where the value is a LeastSquaresSolver.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt id="nengo.utils.least_squares_solvers.format_system">
<code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">format_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">Y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L31-L39"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.format_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract data from A/Y matrices.</p>
</dd></dl>

<dl class="py function">
<dt id="nengo.utils.least_squares_solvers.rmses">
<code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">rmses</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L42-L44"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.rmses" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the root-mean-squared error (RMSE) of the solution X.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.LeastSquaresSolver">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">LeastSquaresSolver</code><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L47-L51"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.LeastSquaresSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear least squares system solver.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.Cholesky">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">Cholesky</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">transpose</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L54-L94"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.Cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using the Cholesky decomposition.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.ConjgradScipy">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">ConjgradScipy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.0001</span></em>, <em class="sig-param"><span class="n">atol</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L97-L158"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.ConjgradScipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using Scipy’s conjugate gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Relative tolerance of the CG solver (see <a class="reference internal" href="#r97899ec83cde-1" id="id20">[1]</a> for details).</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute tolerance of the CG solver (see <a class="reference internal" href="#r97899ec83cde-1" id="id21">[1]</a> for details).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r97899ec83cde-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id20">1</a>,<a href="#id21">2</a>)</span></dt>
<dd><p>scipy.sparse.linalg.cg documentation,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.LSMRScipy">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">LSMRScipy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.0001</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L161-L188"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.LSMRScipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using Scipy’s LSMR.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.Conjgrad">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">Conjgrad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">maxiters</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">X0</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L191-L257"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.Conjgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using conjugate gradient.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.BlockConjgrad">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">BlockConjgrad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">X0</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L260-L309"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.BlockConjgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a multiple-RHS least-squares system using block conj. gradient.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.SVD">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">SVD</code><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L312-L321"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.SVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using full SVD.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.RandomizedSVD">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">RandomizedSVD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_components</span><span class="o">=</span><span class="default_value">60</span></em>, <em class="sig-param"><span class="n">n_oversamples</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">n_iter</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L324-L380"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.RandomizedSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a least-squares system using a randomized (partial) SVD.</p>
<p>Useful for solving large matrices quickly, but non-optimally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n_components</strong><span class="classifier">int, optional</span></dt><dd><p>The number of SVD components to compute. A small survey of activity
matrices suggests that the first 60 components capture almost all
the variance.</p>
</dd>
<dt><strong>n_oversamples</strong><span class="classifier">int, optional</span></dt><dd><p>The number of additional samples on the range of A.</p>
</dd>
<dt><strong>n_iter</strong><span class="classifier">int, optional</span></dt><dd><p>The number of power iterations to perform (can help with noisy data).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference external" href="https://scikit-learn.org/dev/modules/generated/sklearn.utils.extmath.randomized_svd.html#sklearn.utils.extmath.randomized_svd" title="(in scikit-learn v0.24)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.utils.extmath.randomized_svd</span></code></a></dt><dd><p>Function used by this class</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py class">
<dt id="nengo.utils.least_squares_solvers.LeastSquaresSolverParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.utils.least_squares_solvers.</code><code class="sig-name descname">LeastSquaresSolverParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/utils/least_squares_solvers.py#L383-L388"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.utils.least_squares_solvers.LeastSquaresSolverParam" title="Permalink to this definition">¶</a></dt>
<dd><p>A parameter where the value is a LeastSquaresSolver.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-nengo.synapses">
<span id="synapse-models"></span><h2>Synapse models<a class="headerlink" href="#module-nengo.synapses" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.synapses.Synapse" title="nengo.synapses.Synapse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.synapses.Synapse</span></code></a></p></td>
<td><p>Abstract base class for synapse models.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.LinearFilter" title="nengo.LinearFilter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.LinearFilter</span></code></a></p></td>
<td><p>General linear time-invariant (LTI) system synapse.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Lowpass" title="nengo.Lowpass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Lowpass</span></code></a></p></td>
<td><p>Standard first-order lowpass filter synapse.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Alpha" title="nengo.Alpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Alpha</span></code></a></p></td>
<td><p>Alpha-function filter synapse.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.synapses.Triangle" title="nengo.synapses.Triangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.synapses.Triangle</span></code></a></p></td>
<td><p>Triangular finite impulse response (FIR) synapse.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.synapses.Synapse">
<em class="property">class </em><code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">Synapse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">default_size_in</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">default_size_out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">default_dt</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L18-L120"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for synapse models.</p>
<p>Conceptually, a synapse model emulates a biological synapse, taking in
input in the form of released neurotransmitter and opening ion channels
to allow more or less current to flow into the neuron.</p>
<p>In Nengo, the implementation of a synapse is as a specific case of a
<a class="reference internal" href="#nengo.Process" title="nengo.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> in which the input and output shapes are the same.
The input is the current across the synapse, and the output is the current
that will be induced in the postsynaptic neuron.</p>
<p>Synapses also contain the <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse.filt</span></code></a> and <a class="reference internal" href="#nengo.synapses.Synapse.filtfilt" title="nengo.synapses.Synapse.filtfilt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Synapse.filtfilt</span></code></a> methods,
which make it easy to use Nengo’s synapse models outside of Nengo
simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default_size_in</strong><span class="classifier">int, optional</span></dt><dd><p>The size_in used if not specified.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>The size_out used if not specified.
If None, will be the same as default_size_in.</p>
</dd>
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep used if not specified.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>default_dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep used if not specified.</p>
</dd>
<dt><strong>default_size_in</strong><span class="classifier">int</span></dt><dd><p>The size_in used if not specified.</p>
</dd>
<dt><strong>default_size_out</strong><span class="classifier">int</span></dt><dd><p>The size_out used if not specified.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Random number seed. Ensures random factors will be the same each run.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.synapses.Synapse.make_state">
<code class="sig-name descname">make_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L70-L71"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.make_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of signals to represent the state of this process.</p>
<p>The builder uses this to allocate memory for the process state, so
that the state can be represented as part of the whole simulator state.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a></span></dt><dd><p>The data type requested by the builder. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, then this
function is free to choose the best type for the signals involved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>initial_state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to arrays containing the initial state
values. The keys will be used to identify the signals in
<a class="reference internal" href="#nengo.Process.make_step" title="nengo.Process.make_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_step</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.synapses.Synapse.filt">
<code class="sig-name descname">filt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">dt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">filtfilt</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L73-L113"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filt" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter <code class="docutils literal notranslate"><span class="pre">x</span></code> with this synapse model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array_like</span></dt><dd><p>The signal to filter.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float, optional</span></dt><dd><p>The timestep of the input signal.
If None, <code class="docutils literal notranslate"><span class="pre">default_dt</span></code> will be used.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, optional</span></dt><dd><p>The axis along which to filter.</p>
</dd>
<dt><strong>y0</strong><span class="classifier">array_like, optional</span></dt><dd><p>The starting state of the filter output. Must be zero for
unstable linear systems.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to copy the input data, or simply work in-place.</p>
</dd>
<dt><strong>filtfilt</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, runs the process forward then backward on the signal,
for zero-phase filtering (like Matlab’s <code class="docutils literal notranslate"><span class="pre">filtfilt</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.synapses.Synapse.filtfilt">
<code class="sig-name descname">filtfilt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L115-L120"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Synapse.filtfilt" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero-phase filtering of <code class="docutils literal notranslate"><span class="pre">x</span></code> using this filter.</p>
<p>Equivalent to <a class="reference internal" href="#nengo.synapses.Synapse.filt" title="nengo.synapses.Synapse.filt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filt(x,</span> <span class="pre">filtfilt=True,</span> <span class="pre">**kwargs)</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.LinearFilter">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">LinearFilter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num</span></em>, <em class="sig-param"><span class="n">den</span></em>, <em class="sig-param"><span class="n">analog</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'zoh'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L123-L413"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>General linear time-invariant (LTI) system synapse.</p>
<p>This class can be used to implement any linear filter, given the
filter’s transfer function. <a class="reference internal" href="#r15b8b8495338-1" id="id23">[1]</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>num</strong><span class="classifier">array_like</span></dt><dd><p>Numerator coefficients of transfer function.</p>
</dd>
<dt><strong>den</strong><span class="classifier">array_like</span></dt><dd><p>Denominator coefficients of transfer function.</p>
</dd>
<dt><strong>analog</strong><span class="classifier">boolean, optional</span></dt><dd><p>Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string</span></dt><dd><p>The method to use for discretization (if <code class="docutils literal notranslate"><span class="pre">analog</span></code> is True). See
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cont2discrete.html#scipy.signal.cont2discrete" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.cont2discrete</span></code></a> for information about the options.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r15b8b8495338-1"><span class="brackets"><a class="fn-backref" href="#id23">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Filter_%28signal_processing%29">https://en.wikipedia.org/wiki/Filter_%28signal_processing%29</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>analog</strong><span class="classifier">boolean</span></dt><dd><p>Whether the synapse coefficients are analog (i.e. continuous-time),
or discrete. Analog coefficients will be converted to discrete for
simulation using the simulator <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
</dd>
<dt><strong>den</strong><span class="classifier">ndarray</span></dt><dd><p>Denominator coefficients of transfer function.</p>
</dd>
<dt><strong>num</strong><span class="classifier">ndarray</span></dt><dd><p>Numerator coefficients of transfer function.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string</span></dt><dd><p>The method to use for discretization (if <code class="docutils literal notranslate"><span class="pre">analog</span></code> is True). See
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.cont2discrete.html#scipy.signal.cont2discrete" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.signal.cont2discrete</span></code></a> for information about the options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.LinearFilter.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L178-L198"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine in series with another LinearFilter.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.LinearFilter.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frequencies</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L200-L222"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the transfer function at the given frequencies.</p>
<p class="rubric">Examples</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> function to make a Bode plot:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">synapse</span> <span class="o">=</span> <span class="n">nengo</span><span class="o">.</span><span class="n">synapses</span><span class="o">.</span><span class="n">LinearFilter</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.02</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">synapse</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;magnitude [dB]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;frequency [Hz]&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;phase [radians]&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="nengo.LinearFilter.make_state">
<code class="sig-name descname">make_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L233-L277"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.make_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of signals to represent the state of this process.</p>
<p>The builder uses this to allocate memory for the process state, so
that the state can be represented as part of the whole simulator state.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a></span></dt><dd><p>The data type requested by the builder. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, then this
function is free to choose the best type for the signals involved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>initial_state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to arrays containing the initial state
values. The keys will be used to identify the signals in
<a class="reference internal" href="#nengo.Process.make_step" title="nengo.Process.make_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_step</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.LinearFilter.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L279-L297"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.LinearFilter.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#nengo.synapses.LinearFilter.Step" title="nengo.synapses.LinearFilter.Step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Step</span></code></a> instance that implements the linear filter.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.LinearFilter.Step">
<em class="property">class </em><code class="sig-name descname">Step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">C</span></em>, <em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L299-L328"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.LinearFilter.Step" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for LTI filtering step functions.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.LinearFilter.NoX">
<em class="property">class </em><code class="sig-name descname">NoX</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">C</span></em>, <em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L330-L342"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.LinearFilter.NoX" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for system with no state, only passthrough matrix (D).</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.LinearFilter.OneX">
<em class="property">class </em><code class="sig-name descname">OneX</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">C</span></em>, <em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L344-L359"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.LinearFilter.OneX" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for systems with one state element and no passthrough (D).</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.LinearFilter.OneXScalar">
<em class="property">class </em><code class="sig-name descname">OneXScalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">C</span></em>, <em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L361-L373"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.LinearFilter.OneXScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for systems with one state element, no passthrough, and a size-1 input.</p>
<p>Using the builtin float math improves performance.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.LinearFilter.NoD">
<em class="property">class </em><code class="sig-name descname">NoD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">C</span></em>, <em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L375-L393"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.LinearFilter.NoD" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for systems with no passthrough matrix (D).</p>
<p>Implements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span> <span class="n">u</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="n">y</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</pre></div>
</div>
<p>Note how the input has been advanced one step as compared with the
General system below, to remove the unnecessary delay.</p>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.LinearFilter.General">
<em class="property">class </em><code class="sig-name descname">General</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em>, <em class="sig-param"><span class="n">C</span></em>, <em class="sig-param"><span class="n">D</span></em>, <em class="sig-param"><span class="n">X</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L395-L413"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.LinearFilter.General" title="Permalink to this definition">¶</a></dt>
<dd><p>Step for any LTI system with at least one state element (X).</p>
<p>Implements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span> <span class="n">u</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="n">y</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span> <span class="n">u</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">NoX</span></code> for systems with no state elements.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Lowpass">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Lowpass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L416-L438"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Lowpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard first-order lowpass filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.Alpha">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Alpha</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tau</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L441-L470"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha-function filter synapse.</p>
<p>The impulse-response function is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>
</pre></div>
</div>
<p>and was found by <a class="reference internal" href="#r2992f394cf39-1" id="id25">[1]</a> to be a good basic model for synapses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2992f394cf39-1"><span class="brackets"><a class="fn-backref" href="#id25">1</a></span></dt>
<dd><p>Mainen, Z.F. and Sejnowski, T.J. (1995). Reliability of spike timing
in neocortical neurons. Science (New York, NY), 268(5216):1503-6.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tau</strong><span class="classifier">float</span></dt><dd><p>The time constant of the filter in seconds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.Triangle">
<em class="property">class </em><code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">Triangle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L473-L541"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangular finite impulse response (FIR) synapse.</p>
<p>This synapse has a triangular and finite impulse response. The length of
the triangle is <code class="docutils literal notranslate"><span class="pre">t</span></code> seconds; thus the digital filter will have
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">/</span> <span class="pre">dt</span> <span class="pre">+</span> <span class="pre">1</span></code> taps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Length of the triangle, in seconds.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Length of the triangle, in seconds.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.synapses.Triangle.make_state">
<code class="sig-name descname">make_state</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y0</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L510-L524"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle.make_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of signals to represent the state of this process.</p>
<p>The builder uses this to allocate memory for the process state, so
that the state can be represented as part of the whole simulator state.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a></span></dt><dd><p>The data type requested by the builder. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>, then this
function is free to choose the best type for the signals involved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>initial_state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to arrays containing the initial state
values. The keys will be used to identify the signals in
<a class="reference internal" href="#nengo.Process.make_step" title="nengo.Process.make_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_step</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.synapses.Triangle.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape_in</span></em>, <em class="sig-param"><span class="n">shape_out</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">rng</span></em>, <em class="sig-param"><span class="n">state</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L526-L541"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.Triangle.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function that advances the process forward one time step.</p>
<p>This must be implemented by all custom processes. The parameters below
indicate what information is provided by the builder.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape_in</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the input signal.</p>
</dd>
<dt><strong>shape_out</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the output signal.</p>
</dd>
<dt><strong>dt</strong><span class="classifier">float</span></dt><dd><p>The simulation timestep.</p>
</dd>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>A random number generator.</p>
</dd>
<dt><strong>state</strong><span class="classifier">{string: <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>}</span></dt><dd><p>A dictionary mapping keys to signals, where the signals fully
represent the state of the process. The signals are initialized
by <a class="reference internal" href="#nengo.Process.make_state" title="nengo.Process.make_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.make_state</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.synapses.SynapseParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.synapses.</code><code class="sig-name descname">SynapseParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/synapses.py#L544-L553"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.synapses.SynapseParam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nengo.transforms">
<span id="transforms"></span><h2>Transforms<a class="headerlink" href="#module-nengo.transforms" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.transforms.Transform" title="nengo.transforms.Transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.Transform</span></code></a></p></td>
<td><p>A base class for connection transforms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Dense" title="nengo.Dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Dense</span></code></a></p></td>
<td><p>A dense matrix transformation between an input and output signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.transforms.SparseMatrix" title="nengo.transforms.SparseMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.SparseMatrix</span></code></a></p></td>
<td><p>Represents a sparse matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.Sparse" title="nengo.Sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Sparse</span></code></a></p></td>
<td><p>A sparse matrix transformation between an input and output signal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.Convolution" title="nengo.Convolution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.Convolution</span></code></a></p></td>
<td><p>An N-dimensional convolutional transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nengo.transforms.ChannelShape" title="nengo.transforms.ChannelShape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.ChannelShape</span></code></a></p></td>
<td><p>Represents shape information with variable channel position.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#nengo.transforms.NoTransform" title="nengo.transforms.NoTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nengo.transforms.NoTransform</span></code></a></p></td>
<td><p>Directly pass the signal through without any transform operations.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt id="nengo.transforms.Transform">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">Transform</code><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L20-L49"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A base class for connection transforms.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="py method">
<dt id="nengo.transforms.Transform.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L26-L39"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.Transform.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Transform.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Transform.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Transform.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Transform.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.transforms.ChannelShapeParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">ChannelShapeParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">length</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">low</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L52-L71"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.ChannelShapeParam" title="Permalink to this definition">¶</a></dt>
<dd><p>A parameter where the value must be a shape with channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt id="nengo.Dense">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Dense</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L74-L142"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Dense" title="Permalink to this definition">¶</a></dt>
<dd><p>A dense matrix transformation between an input and output signal.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>The shape of the dense matrix: <code class="docutils literal notranslate"><span class="pre">(size_out,</span> <span class="pre">size_in)</span></code>.</p>
</dd>
<dt><strong>init</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or array_like, optional</span></dt><dd><p>A Distribution used to initialize the transform matrix, or a concrete
instantiation for the matrix. If the matrix is square we also allow a
scalar (equivalent to <code class="docutils literal notranslate"><span class="pre">np.eye(n)</span> <span class="pre">*</span> <span class="pre">init</span></code>) or a vector (equivalent to
<code class="docutils literal notranslate"><span class="pre">np.diag(init)</span></code>) to represent the matrix more compactly.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Dense.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L125-L129"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Dense.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Dense.init_shape">
<em class="property">property </em><code class="sig-name descname">init_shape</code><a class="headerlink" href="#nengo.transforms.Dense.init_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the initial value.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Dense.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Dense.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Dense.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Dense.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.transforms.SparseInitParam">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">SparseInitParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">default</span><span class="o">=</span><span class="default_value">Unconfigurable</span></em>, <em class="sig-param"><span class="n">optional</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">readonly</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L145-L157"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.SparseInitParam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="nengo.transforms.SparseMatrix">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">SparseMatrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">shape</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L160-L279"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.SparseMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a sparse matrix.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>indices</strong><span class="classifier">array_like of int</span></dt><dd><p>An Nx2 array of integers indicating the (row,col) coordinates for the
N non-zero elements in the matrix.</p>
</dd>
<dt><strong>data</strong><span class="classifier">array_like or <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a></span></dt><dd><p>An Nx1 array defining the value of the nonzero elements in the matrix
(corresponding to <code class="docutils literal notranslate"><span class="pre">indices</span></code>), or a <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> that will be
used to initialize the nonzero elements.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>Shape of the full matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.transforms.SparseMatrix.allocate">
<code class="sig-name descname">allocate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L219-L242"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.SparseMatrix.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a> or dense matrix equivalent.</p>
<p>We mark this data as readonly to be consistent with how other
data associated with signals are allocated. If this allocated
data is to be modified, it should be copied first.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.SparseMatrix.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L244-L267"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.SparseMatrix.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> data to fixed array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></span></dt><dd><p>Random number generator that will be used when
sampling distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>matrix</strong><span class="classifier"><a class="reference internal" href="#nengo.transforms.SparseMatrix" title="nengo.transforms.SparseMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseMatrix</span></code></a></span></dt><dd><p>A new <a class="reference internal" href="#nengo.transforms.SparseMatrix" title="nengo.transforms.SparseMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseMatrix</span></code></a> instance with <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> converted to
array if <code class="docutils literal notranslate"><span class="pre">self.data</span></code> is a <a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a>, otherwise simply
returns <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.SparseMatrix.toarray">
<code class="sig-name descname">toarray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L269-L279"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.SparseMatrix.toarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dense matrix equivalent of this matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Sparse">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Sparse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L282-L338"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix transformation between an input and output signal.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>The full shape of the sparse matrix: <code class="docutils literal notranslate"><span class="pre">(size_out,</span> <span class="pre">size_in)</span></code>.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">array_like of int</span></dt><dd><p>An Nx2 array of integers indicating the (row,col) coordinates for the
N non-zero elements in the matrix.</p>
</dd>
<dt><strong>init</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or array_like, optional</span></dt><dd><p>A Distribution used to initialize the transform matrix, or a concrete
instantiation for the matrix. If the matrix is square we also allow a
scalar (equivalent to <code class="docutils literal notranslate"><span class="pre">np.eye(n)</span> <span class="pre">*</span> <span class="pre">init</span></code>) or a vector (equivalent to
<code class="docutils literal notranslate"><span class="pre">np.diag(init)</span></code>) to represent the matrix more compactly.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.Sparse.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L326-L330"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Sparse.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Sparse.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Sparse.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Sparse.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Sparse.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.Convolution">
<em class="property">class </em><code class="sig-prename descclassname">nengo.</code><code class="sig-name descname">Convolution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n_filters</span></em>, <em class="sig-param"><span class="n">input_shape</span></em>, <em class="sig-param"><span class="n">kernel_size</span><span class="o">=</span><span class="default_value">3, 3</span></em>, <em class="sig-param"><span class="n">strides</span><span class="o">=</span><span class="default_value">1, 1</span></em>, <em class="sig-param"><span class="n">padding</span><span class="o">=</span><span class="default_value">'valid'</span></em>, <em class="sig-param"><span class="n">channels_last</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">Uniform(low=- 1, high=1)</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L341-L496"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Convolution" title="Permalink to this definition">¶</a></dt>
<dd><p>An N-dimensional convolutional transform.</p>
<p>The dimensionality of the convolution is determined by the input shape.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_filters</strong><span class="classifier">int</span></dt><dd><p>The number of convolutional filters to apply</p>
</dd>
<dt><strong>input_shape</strong><span class="classifier">tuple of int or <a class="reference internal" href="#nengo.transforms.ChannelShape" title="nengo.transforms.ChannelShape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ChannelShape</span></code></a></span></dt><dd><p>Shape of the input signal to the convolution; e.g.,
<code class="docutils literal notranslate"><span class="pre">(height,</span> <span class="pre">width,</span> <span class="pre">channels)</span></code> for a 2D convolution with
<code class="docutils literal notranslate"><span class="pre">channels_last=True</span></code>.</p>
</dd>
<dt><strong>kernel_size</strong><span class="classifier">tuple of int, optional</span></dt><dd><p>Size of the convolutional kernels (1 element for a 1D convolution,
2 for a 2D convolution, etc.).</p>
</dd>
<dt><strong>strides</strong><span class="classifier">tuple of int, optional</span></dt><dd><p>Stride of the convolution (1 element for a 1D convolution, 2 for
a 2D convolution, etc.).</p>
</dd>
<dt><strong>padding</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">&quot;same&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;valid&quot;</span></code>, optional</span></dt><dd><p>Padding method for input signal. “Valid” means no padding, and
convolution will only be applied to the fully-overlapping areas of the
input signal (meaning the output will be smaller). “Same” means that
the input signal is zero-padded so that the output is the same shape
as the input.</p>
</dd>
<dt><strong>channels_last</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), the channels are the last dimension in the input
signal (e.g., a 28x28 image with 3 channels would have shape
<code class="docutils literal notranslate"><span class="pre">(28,</span> <span class="pre">28,</span> <span class="pre">3)</span></code>).  <code class="docutils literal notranslate"><span class="pre">False</span></code> means that channels are the first
dimension (e.g., <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">28,</span> <span class="pre">28)</span></code>).</p>
</dd>
<dt><strong>init</strong><span class="classifier"><a class="reference internal" href="#nengo.dists.Distribution" title="nengo.dists.Distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Distribution</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code></a>, optional</span></dt><dd><p>A predefined kernel with shape
<code class="docutils literal notranslate"><span class="pre">kernel_size</span> <span class="pre">+</span> <span class="pre">(input_channels,</span> <span class="pre">n_filters)</span></code>, or a <code class="docutils literal notranslate"><span class="pre">Distribution</span></code>
that will be used to initialize the kernel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As is typical in neural networks, this is technically correlation rather
than convolution (because the kernel is not flipped).</p>
<dl class="py method">
<dt id="nengo.Convolution.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L450-L461"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.Convolution.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>array_like</dt><dd><p>Transform weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Convolution.kernel_shape">
<em class="property">property </em><code class="sig-name descname">kernel_shape</code><a class="headerlink" href="#nengo.transforms.Convolution.kernel_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Full shape of kernel.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Convolution.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.Convolution.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Convolution.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.Convolution.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Convolution.dimensions">
<em class="property">property </em><code class="sig-name descname">dimensions</code><a class="headerlink" href="#nengo.transforms.Convolution.dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimensionality of convolution.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.Convolution.output_shape">
<em class="property">property </em><code class="sig-name descname">output_shape</code><a class="headerlink" href="#nengo.transforms.Convolution.output_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Output shape after applying convolution to input.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.transforms.ChannelShape">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">ChannelShape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">channels_last</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L499-L563"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.ChannelShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents shape information with variable channel position.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.0.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>Signal shape</p>
</dd>
<dt><strong>channels_last</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), the last item in <code class="docutils literal notranslate"><span class="pre">shape</span></code> represents the channels,
and the rest are spatial dimensions. Otherwise, the first item in
<code class="docutils literal notranslate"><span class="pre">shape</span></code> is the channel dimension.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.transforms.ChannelShape.spatial_shape">
<em class="property">property </em><code class="sig-name descname">spatial_shape</code><a class="headerlink" href="#nengo.transforms.ChannelShape.spatial_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The spatial part of the shape (omitting channels).</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.ChannelShape.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#nengo.transforms.ChannelShape.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of elements in the represented signal.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.ChannelShape.n_channels">
<em class="property">property </em><code class="sig-name descname">n_channels</code><a class="headerlink" href="#nengo.transforms.ChannelShape.n_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of channels in the represented signal.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.ChannelShape.dimensions">
<em class="property">property </em><code class="sig-name descname">dimensions</code><a class="headerlink" href="#nengo.transforms.ChannelShape.dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>The spatial dimensionality of the represented signal.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nengo.transforms.NoTransform">
<em class="property">class </em><code class="sig-prename descclassname">nengo.transforms.</code><code class="sig-name descname">NoTransform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">size_in</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L566-L606"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.NoTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Directly pass the signal through without any transform operations.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3.1.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>size_in</strong><span class="classifier">int</span></dt><dd><p>Dimensionality of transform input and output.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="nengo.transforms.NoTransform.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">rng</span><span class="o">=</span><span class="default_value">numpy.random</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/nengo/nengo/blob/v3.1.0/nengo/transforms.py#L582-L596"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nengo.transforms.NoTransform.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns concrete weights to implement the specified transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rng</strong><span class="classifier"><a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a>, optional</span></dt><dd><p>Random number generator state.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>There is nothing to sample for NoTransform, so it is an error
if this is called.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.NoTransform.size_in">
<em class="property">property </em><code class="sig-name descname">size_in</code><a class="headerlink" href="#nengo.transforms.NoTransform.size_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of input to transform.</p>
</dd></dl>

<dl class="py method">
<dt id="nengo.transforms.NoTransform.size_out">
<em class="property">property </em><code class="sig-name descname">size_out</code><a class="headerlink" href="#nengo.transforms.NoTransform.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Expected size of output from transform.</p>
</dd></dl>

</dd></dl>

</div>
</div>


            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div><footer class="text-light footer-main gradient-bottom">
  <p class="small text-center mb-0">
    <a class="no-hover-line" href="https://appliedbrainresearch.com">
      <img
        src="https://appliedbrainresearch.com/img/logo-blue-notext.svg"
        height="48"
      />
    </a>
    <a href="https://www.nengo.ai/">What is Nengo?</a>
    <a href="https://www.nengo.ai/examples/">Examples</a>
    <a href="https://www.nengo.ai/documentation/">Documentation</a>
    <a href="https://www.nengo.ai/getting-started/">Getting started</a>
    <a href="https://www.nengo.ai/privacy/">Privacy</a>
  </p>
  <p class="small text-center mb-0">&copy; Applied Brain Research</p>
</footer>
<script>
  function switchVersion(select) {
    var option = select.selectedOptions[0];
    if (option.hasAttribute("value")) {
      window.location = option.value;
    }
  }
</script>

<script>
  var elements = document.querySelectorAll('.sidenav');
  Stickyfill.add(elements);
</script>
<script>
  ScrollReveal().reveal(".fade-in", {
      scale: 0.85,
      duration: 1000,
      delay: 250,
      interval: 50
  });
</script>
<script>
  $('a.toggle-sidenav').on('click', function(e) {
    e.preventDefault();
    if ( $(this).hasClass('active') ) {
      $(this).removeClass('active');
      $('.sidenav').removeClass('open');
    } else {
      $(this).addClass('active');
      $('.sidenav').addClass('open');
    }
  });
</script>
<script>
  var lists = document.querySelectorAll('.toctree ul');
  lists.forEach((ul) => {
      ul.classList.add("nav");
  });
  var links = document.querySelectorAll('.toctree a');
  links.forEach((link) => {
      link.classList.add("nav-link");
  });
  $("body").scrollspy({target: ".sidenav"});
</script>
  </body>
</html>